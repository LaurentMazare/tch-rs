// THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND!

tensor *atg_abs(tensor self) {
  PROTECT(
    auto outputs__ = torch::abs(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_abs_(tensor self) {
  PROTECT(
    auto outputs__ = torch::abs_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_abs_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::abs_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_acos(tensor self) {
  PROTECT(
    auto outputs__ = torch::acos(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_acos_(tensor self) {
  PROTECT(
    auto outputs__ = torch::acos_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_acos_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::acos_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_avg_pool1d(tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool1d(*self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_avg_pool2d(tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool2d(*self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_avg_pool2d_backward(tensor grad_output, tensor self) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool2d_backward(*grad_output, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_avg_pool2d_backward_out(tensor grad_input, tensor grad_output, tensor self) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool2d_backward_out(*grad_input, *grad_output, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_avg_pool2d_out(tensor output, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool2d_out(*output, *self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_avg_pool3d(tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool3d(*self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_avg_pool3d_backward(tensor grad_output, tensor self) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool3d_backward(*grad_output, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_avg_pool3d_backward_out(tensor grad_input, tensor grad_output, tensor self) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool3d_backward_out(*grad_input, *grad_output, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_avg_pool3d_out(tensor output, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool3d_out(*output, *self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_max_pool1d(tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool1d(*self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_adaptive_max_pool2d(tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool2d(*self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_adaptive_max_pool2d_backward(tensor grad_output, tensor self, tensor indices) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool2d_backward(*grad_output, *self, *indices);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_max_pool2d_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor indices) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool2d_backward_out(*grad_input, *grad_output, *self, *indices);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_max_pool2d_out(tensor output, tensor indices, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool2d_out(*output, *indices, *self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_adaptive_max_pool3d(tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool3d(*self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_adaptive_max_pool3d_backward(tensor grad_output, tensor self, tensor indices) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool3d_backward(*grad_output, *self, *indices);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_max_pool3d_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor indices) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool3d_backward_out(*grad_input, *grad_output, *self, *indices);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_adaptive_max_pool3d_out(tensor output, tensor indices, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool3d_out(*output, *indices, *self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_add(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::add(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_add1(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::add(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_add_(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->add_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_add_1(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->add_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_add_out(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::add_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addbmm(tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = torch::addbmm(*self, *batch1, *batch2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addbmm_(tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = self->addbmm_(*batch1, *batch2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addbmm_out(tensor result, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = torch::addbmm_out(*result, *self, *batch1, *batch2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addcdiv(tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = torch::addcdiv(*self, *tensor1, *tensor2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addcdiv_(tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = self->addcdiv_(*tensor1, *tensor2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addcdiv_out(tensor result, tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = torch::addcdiv_out(*result, *self, *tensor1, *tensor2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addcmul(tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = torch::addcmul(*self, *tensor1, *tensor2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addcmul_(tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = self->addcmul_(*tensor1, *tensor2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addcmul_out(tensor result, tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = torch::addcmul_out(*result, *self, *tensor1, *tensor2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addmm(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::addmm(*self, *mat1, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addmm_(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = self->addmm_(*mat1, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::addmm_out(*result, *self, *mat1, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addmv(tensor self, tensor mat, tensor vec) {
  PROTECT(
    auto outputs__ = torch::addmv(*self, *mat, *vec);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addmv_(tensor self, tensor mat, tensor vec) {
  PROTECT(
    auto outputs__ = torch::addmv_(*self, *mat, *vec);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addmv_out(tensor result, tensor self, tensor mat, tensor vec) {
  PROTECT(
    auto outputs__ = torch::addmv_out(*result, *self, *mat, *vec);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addr(tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    auto outputs__ = torch::addr(*self, *vec1, *vec2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addr_(tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    auto outputs__ = self->addr_(*vec1, *vec2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_addr_out(tensor result, tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    auto outputs__ = torch::addr_out(*result, *self, *vec1, *vec2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_alias(tensor self) {
  PROTECT(
    auto outputs__ = torch::alias(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_all(tensor self) {
  PROTECT(
    auto outputs__ = torch::all(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_all1(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::all(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_all_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::all_out(*result, *self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_alpha_dropout(tensor input, double p, int train) {
  PROTECT(
    auto outputs__ = torch::alpha_dropout(*input, p, (bool)train);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_alpha_dropout_(tensor self, double p, int train) {
  PROTECT(
    auto outputs__ = torch::alpha_dropout_(*self, p, (bool)train);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_any(tensor self) {
  PROTECT(
    auto outputs__ = torch::any(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_any1(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::any(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_any_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::any_out(*result, *self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_arange(scalar end, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::arange(*end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_arange1(scalar start, scalar end, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::arange(*start, *end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_arange2(scalar start, scalar end, scalar step, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::arange(*start, *end, *step, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_arange_out(tensor result, scalar end) {
  PROTECT(
    auto outputs__ = torch::arange_out(*result, *end);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_arange_out1(tensor result, scalar start, scalar end) {
  PROTECT(
    auto outputs__ = torch::arange_out(*result, *start, *end);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_arange_out2(tensor result, scalar start, scalar end, scalar step) {
  PROTECT(
    auto outputs__ = torch::arange_out(*result, *start, *end, *step);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_argmax(tensor self) {
  PROTECT(
    auto outputs__ = torch::argmax(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_argmax1(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::argmax(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_argmin(tensor self) {
  PROTECT(
    auto outputs__ = torch::argmin(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_argmin1(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::argmin(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_as_strided(tensor self, int64_t *size_data, int size_len, int64_t *stride_data, int stride_len) {
  PROTECT(
    auto outputs__ = torch::as_strided(*self, torch::IntList(size_data, size_len), torch::IntList(stride_data, stride_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_as_strided1(tensor self, int64_t *size_data, int size_len, int64_t *stride_data, int stride_len, int64_t storage_offset) {
  PROTECT(
    auto outputs__ = torch::as_strided(*self, torch::IntList(size_data, size_len), torch::IntList(stride_data, stride_len), storage_offset);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_as_strided_(tensor self, int64_t *size_data, int size_len, int64_t *stride_data, int stride_len) {
  PROTECT(
    auto outputs__ = torch::as_strided_(*self, torch::IntList(size_data, size_len), torch::IntList(stride_data, stride_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_as_strided_1(tensor self, int64_t *size_data, int size_len, int64_t *stride_data, int stride_len, int64_t storage_offset) {
  PROTECT(
    auto outputs__ = torch::as_strided_(*self, torch::IntList(size_data, size_len), torch::IntList(stride_data, stride_len), storage_offset);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_asin(tensor self) {
  PROTECT(
    auto outputs__ = torch::asin(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_asin_(tensor self) {
  PROTECT(
    auto outputs__ = torch::asin_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_asin_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::asin_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_atan(tensor self) {
  PROTECT(
    auto outputs__ = torch::atan(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_atan2(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::atan2(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_atan2_(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->atan2_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_atan2_out(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::atan2_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_atan_(tensor self) {
  PROTECT(
    auto outputs__ = torch::atan_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_atan_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::atan_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_avg_pool1d(tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    auto outputs__ = torch::avg_pool1d(*self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_avg_pool2d(tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    auto outputs__ = torch::avg_pool2d(*self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_avg_pool2d_backward(tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    auto outputs__ = torch::avg_pool2d_backward(*grad_output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_avg_pool2d_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    auto outputs__ = torch::avg_pool2d_backward_out(*grad_input, *grad_output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_avg_pool2d_out(tensor output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    auto outputs__ = torch::avg_pool2d_out(*output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_avg_pool3d(tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    auto outputs__ = torch::avg_pool3d(*self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_avg_pool3d_backward(tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    auto outputs__ = torch::avg_pool3d_backward(*grad_output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_avg_pool3d_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    auto outputs__ = torch::avg_pool3d_backward_out(*grad_input, *grad_output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_avg_pool3d_out(tensor output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    auto outputs__ = torch::avg_pool3d_out(*output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_baddbmm(tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = torch::baddbmm(*self, *batch1, *batch2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_baddbmm_(tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = self->baddbmm_(*batch1, *batch2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_baddbmm_out(tensor result, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = torch::baddbmm_out(*result, *self, *batch1, *batch2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_bartlett_window(int64_t window_length, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::bartlett_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_bartlett_window1(int64_t window_length, int periodic, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::bartlett_window(window_length, (bool)periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_batch_norm(tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double momentum, double eps, int cudnn_enabled) {
  PROTECT(
    auto outputs__ = torch::batch_norm(*input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)training, momentum, eps, (bool)cudnn_enabled);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_bernoulli(tensor self) {
  PROTECT(
    auto outputs__ = torch::bernoulli(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_bernoulli1(tensor self, double p) {
  PROTECT(
    auto outputs__ = torch::bernoulli(*self, p);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_bernoulli_(tensor self, tensor p) {
  PROTECT(
    auto outputs__ = self->bernoulli_(*p);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_bernoulli_1(tensor self, double p) {
  PROTECT(
    auto outputs__ = self->bernoulli_(p);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_bernoulli_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::bernoulli_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_bilinear(tensor input1, tensor input2, tensor weight, tensor bias) {
  PROTECT(
    auto outputs__ = torch::bilinear(*input1, *input2, *weight, (bias ? *bias : torch::Tensor()));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_binary_cross_entropy(tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy(*self, *target, *weight, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_binary_cross_entropy_backward(tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy_backward(*grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_binary_cross_entropy_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy_backward_out(*grad_input, *grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_binary_cross_entropy_out(tensor output, tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy_out(*output, *self, *target, *weight, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_binary_cross_entropy_with_logits(tensor self, tensor target, tensor weight, tensor pos_weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy_with_logits(*self, *target, (weight ? *weight : torch::Tensor()), (pos_weight ? *pos_weight : torch::Tensor()), reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_binary_cross_entropy_with_logits_backward(tensor grad_output, tensor self, tensor target, tensor weight, tensor pos_weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy_with_logits_backward(*grad_output, *self, *target, (weight ? *weight : torch::Tensor()), (pos_weight ? *pos_weight : torch::Tensor()), reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_bincount(tensor self, tensor weights, int64_t minlength) {
  PROTECT(
    auto outputs__ = torch::bincount(*self, (weights ? *weights : torch::Tensor()), minlength);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_blackman_window(int64_t window_length, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::blackman_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_blackman_window1(int64_t window_length, int periodic, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::blackman_window(window_length, (bool)periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_bmm(tensor self, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::bmm(*self, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_bmm_out(tensor result, tensor self, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::bmm_out(*result, *self, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_broadcast_tensors(tensor *tensors_data, int tensors_len) {
  PROTECT(
    auto outputs__ = torch::broadcast_tensors(of_carray_tensor(tensors_data, tensors_len));
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
}

tensor *atg_btrifact(tensor self, int pivot) {
  PROTECT(
    auto outputs__ = torch::btrifact(*self, (bool)pivot);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_btrifact_out(tensor A_LU, tensor pivots, tensor self, int pivot) {
  PROTECT(
    auto outputs__ = torch::btrifact_out(*A_LU, *pivots, *self, (bool)pivot);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_btrifact_with_info(tensor self, int pivot) {
  PROTECT(
    auto outputs__ = torch::btrifact_with_info(*self, (bool)pivot);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_btrifact_with_info_out(tensor A_LU, tensor pivots, tensor info, tensor self, int pivot) {
  PROTECT(
    auto outputs__ = torch::btrifact_with_info_out(*A_LU, *pivots, *info, *self, (bool)pivot);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_btrisolve(tensor self, tensor LU_data, tensor LU_pivots) {
  PROTECT(
    auto outputs__ = torch::btrisolve(*self, *LU_data, *LU_pivots);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_btrisolve_out(tensor result, tensor self, tensor LU_data, tensor LU_pivots) {
  PROTECT(
    auto outputs__ = torch::btrisolve_out(*result, *self, *LU_data, *LU_pivots);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cat(tensor *tensors_data, int tensors_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cat(of_carray_tensor(tensors_data, tensors_len), dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cat_out(tensor result, tensor *tensors_data, int tensors_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cat_out(*result, of_carray_tensor(tensors_data, tensors_len), dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cauchy_(tensor self, double median, double sigma) {
  PROTECT(
    auto outputs__ = self->cauchy_(median, sigma);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ceil(tensor self) {
  PROTECT(
    auto outputs__ = torch::ceil(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ceil_(tensor self) {
  PROTECT(
    auto outputs__ = torch::ceil_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ceil_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::ceil_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_celu(tensor self) {
  PROTECT(
    auto outputs__ = torch::celu(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_celu_(tensor self) {
  PROTECT(
    auto outputs__ = torch::celu_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_chain_matmul(tensor *matrices_data, int matrices_len) {
  PROTECT(
    auto outputs__ = torch::chain_matmul(of_carray_tensor(matrices_data, matrices_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cholesky(tensor self, int upper) {
  PROTECT(
    auto outputs__ = torch::cholesky(*self, (bool)upper);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cholesky_out(tensor result, tensor self, int upper) {
  PROTECT(
    auto outputs__ = torch::cholesky_out(*result, *self, (bool)upper);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_chunk(tensor self, int64_t chunks, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::chunk(*self, chunks, dim);
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
}

tensor *atg_clamp(tensor self, scalar min, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp(*self, *min, *max);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_clamp_(tensor self, scalar min, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp_(*self, *min, *max);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_clamp_max(tensor self, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp_max(*self, *max);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_clamp_max_(tensor self, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp_max_(*self, *max);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_clamp_max_out(tensor result, tensor self, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp_max_out(*result, *self, *max);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_clamp_min(tensor self, scalar min) {
  PROTECT(
    auto outputs__ = torch::clamp_min(*self, *min);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_clamp_min_(tensor self, scalar min) {
  PROTECT(
    auto outputs__ = torch::clamp_min_(*self, *min);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_clamp_min_out(tensor result, tensor self, scalar min) {
  PROTECT(
    auto outputs__ = torch::clamp_min_out(*result, *self, *min);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_clamp_out(tensor result, tensor self, scalar min, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp_out(*result, *self, *min, *max);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_coalesce(tensor self) {
  PROTECT(
    auto outputs__ = self->coalesce();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_constant_pad_nd(tensor self, int64_t *pad_data, int pad_len) {
  PROTECT(
    auto outputs__ = torch::constant_pad_nd(*self, torch::IntList(pad_data, pad_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_contiguous(tensor self) {
  PROTECT(
    auto outputs__ = self->contiguous();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_conv1d(tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::conv1d(*input, *weight, *bias, torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), groups);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_conv2d(tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::conv2d(*input, *weight, *bias, torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), groups);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_conv3d(tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::conv3d(*input, *weight, *bias, torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), groups);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_conv_tbc(tensor self, tensor weight, tensor bias, int64_t pad) {
  PROTECT(
    auto outputs__ = torch::conv_tbc(*self, *weight, *bias, pad);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_conv_tbc_backward(tensor self, tensor input, tensor weight, tensor bias, int64_t pad) {
  PROTECT(
    auto outputs__ = torch::conv_tbc_backward(*self, *input, *weight, *bias, pad);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_conv_transpose1d(tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t groups, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::conv_transpose1d(*input, *weight, *bias, torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(output_padding_data, output_padding_len), groups, torch::IntList(dilation_data, dilation_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_conv_transpose2d(tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t groups, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::conv_transpose2d(*input, *weight, *bias, torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(output_padding_data, output_padding_len), groups, torch::IntList(dilation_data, dilation_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_conv_transpose3d(tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t groups, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::conv_transpose3d(*input, *weight, *bias, torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(output_padding_data, output_padding_len), groups, torch::IntList(dilation_data, dilation_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_convolution(tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int transposed, int64_t *output_padding_data, int output_padding_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::convolution(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)transposed, torch::IntList(output_padding_data, output_padding_len), groups);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_copy_sparse_to_sparse_(tensor self, tensor src, int non_blocking) {
  PROTECT(
    auto outputs__ = torch::copy_sparse_to_sparse_(*self, *src, (bool)non_blocking);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cos(tensor self) {
  PROTECT(
    auto outputs__ = torch::cos(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cos_(tensor self) {
  PROTECT(
    auto outputs__ = torch::cos_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cos_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::cos_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cosh(tensor self) {
  PROTECT(
    auto outputs__ = torch::cosh(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cosh_(tensor self) {
  PROTECT(
    auto outputs__ = torch::cosh_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cosh_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::cosh_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cosine_embedding_loss(tensor input1, tensor input2, tensor target, double margin, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::cosine_embedding_loss(*input1, *input2, *target, margin, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cross(tensor self, tensor other, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cross(*self, *other, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cross_out(tensor result, tensor self, tensor other, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cross_out(*result, *self, *other, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ctc_loss(tensor log_probs, tensor targets, int64_t *input_lengths_data, int input_lengths_len, int64_t *target_lengths_data, int target_lengths_len, int64_t blank, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::ctc_loss(*log_probs, *targets, torch::IntList(input_lengths_data, input_lengths_len), torch::IntList(target_lengths_data, target_lengths_len), blank, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ctc_loss1(tensor log_probs, tensor targets, tensor input_lengths, tensor target_lengths, int64_t blank, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::ctc_loss(*log_probs, *targets, *input_lengths, *target_lengths, blank, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_affine_grid_generator(tensor theta, int64_t N, int64_t C, int64_t H, int64_t W) {
  PROTECT(
    auto outputs__ = torch::cudnn_affine_grid_generator(*theta, N, C, H, W);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_affine_grid_generator_backward(tensor grad, int64_t N, int64_t C, int64_t H, int64_t W) {
  PROTECT(
    auto outputs__ = torch::cudnn_affine_grid_generator_backward(*grad, N, C, H, W);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_batch_norm(tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double exponential_average_factor, double epsilon) {
  PROTECT(
    auto outputs__ = torch::cudnn_batch_norm(*input, *weight, (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)training, exponential_average_factor, epsilon);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_cudnn_batch_norm_backward(tensor input, tensor grad_output, tensor weight, tensor running_mean, tensor running_var, tensor save_mean, tensor save_var, double epsilon) {
  PROTECT(
    auto outputs__ = torch::cudnn_batch_norm_backward(*input, *grad_output, *weight, (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (save_mean ? *save_mean : torch::Tensor()), (save_var ? *save_var : torch::Tensor()), epsilon);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_cudnn_convolution(tensor self, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution(*self, *weight, (bias ? *bias : torch::Tensor()), torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_convolution_backward_bias(tensor grad_output) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_backward_bias(*grad_output);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_convolution_backward_input(int64_t *self_size_data, int self_size_len, tensor grad_output, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_backward_input(torch::IntList(self_size_data, self_size_len), *grad_output, *weight, torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_convolution_backward_weight(int64_t *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_backward_weight(torch::IntList(weight_size_data, weight_size_len), *grad_output, *self, torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_convolution_transpose(tensor self, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_transpose(*self, *weight, (bias ? *bias : torch::Tensor()), torch::IntList(padding_data, padding_len), torch::IntList(output_padding_data, output_padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_convolution_transpose_backward_bias(tensor grad_output) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_transpose_backward_bias(*grad_output);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_convolution_transpose_backward_input(tensor grad_output, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_transpose_backward_input(*grad_output, *weight, torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_convolution_transpose_backward_weight(int64_t *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_transpose_backward_weight(torch::IntList(weight_size_data, weight_size_len), *grad_output, *self, torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_grid_sampler(tensor self, tensor grid) {
  PROTECT(
    auto outputs__ = torch::cudnn_grid_sampler(*self, *grid);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cudnn_grid_sampler_backward(tensor self, tensor grid, tensor grad_output) {
  PROTECT(
    auto outputs__ = torch::cudnn_grid_sampler_backward(*self, *grid, *grad_output);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_cumprod(tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cumprod(*self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cumprod1(tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::cumprod(*self, dim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cumprod_out(tensor result, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cumprod_out(*result, *self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cumprod_out1(tensor result, tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::cumprod_out(*result, *self, dim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cumsum(tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cumsum(*self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cumsum1(tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::cumsum(*self, dim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cumsum_out(tensor result, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cumsum_out(*result, *self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_cumsum_out1(tensor result, tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::cumsum_out(*result, *self, dim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_det(tensor self) {
  PROTECT(
    auto outputs__ = torch::det(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_detach(tensor self) {
  PROTECT(
    auto outputs__ = torch::detach(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_detach_(tensor self) {
  PROTECT(
    auto outputs__ = torch::detach_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_diag(tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::diag(*self, diagonal);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_diag_embed(tensor self, int64_t offset, int64_t dim1, int64_t dim2) {
  PROTECT(
    auto outputs__ = torch::diag_embed(*self, offset, dim1, dim2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_diag_out(tensor result, tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::diag_out(*result, *self, diagonal);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_diagflat(tensor self, int64_t offset) {
  PROTECT(
    auto outputs__ = torch::diagflat(*self, offset);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_diagonal(tensor self, int64_t offset, int64_t dim1, int64_t dim2) {
  PROTECT(
    auto outputs__ = torch::diagonal(*self, offset, dim1, dim2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_digamma(tensor self) {
  PROTECT(
    auto outputs__ = torch::digamma(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_digamma_(tensor self) {
  PROTECT(
    auto outputs__ = self->digamma_();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_digamma_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::digamma_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_dist(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::dist(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_div(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::div(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_div1(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::div(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_div_(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->div_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_div_1(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->div_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_div_out(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::div_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_dot(tensor self, tensor tensor) {
  PROTECT(
    auto outputs__ = torch::dot(*self, *tensor);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_dot_out(tensor result, tensor self, tensor tensor) {
  PROTECT(
    auto outputs__ = torch::dot_out(*result, *self, *tensor);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_dropout(tensor input, double p, int train) {
  PROTECT(
    auto outputs__ = torch::dropout(*input, p, (bool)train);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_dropout_(tensor self, double p, int train) {
  PROTECT(
    auto outputs__ = torch::dropout_(*self, p, (bool)train);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_eig(tensor self, int eigenvectors) {
  PROTECT(
    auto outputs__ = torch::eig(*self, (bool)eigenvectors);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_eig_out(tensor e, tensor v, tensor self, int eigenvectors) {
  PROTECT(
    auto outputs__ = torch::eig_out(*e, *v, *self, (bool)eigenvectors);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_elu(tensor self) {
  PROTECT(
    auto outputs__ = torch::elu(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_elu_(tensor self) {
  PROTECT(
    auto outputs__ = torch::elu_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_elu_out(tensor output, tensor self) {
  PROTECT(
    auto outputs__ = torch::elu_out(*output, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_embedding(tensor weight, tensor indices, int64_t padding_idx, int scale_grad_by_freq, int sparse) {
  PROTECT(
    auto outputs__ = torch::embedding(*weight, *indices, padding_idx, (bool)scale_grad_by_freq, (bool)sparse);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_embedding_backward(tensor grad, tensor indices, int64_t num_weights, int64_t padding_idx, int scale_grad_by_freq, int sparse) {
  PROTECT(
    auto outputs__ = torch::embedding_backward(*grad, *indices, num_weights, padding_idx, (bool)scale_grad_by_freq, (bool)sparse);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_embedding_bag(tensor weight, tensor indices, tensor offsets, int scale_grad_by_freq, int64_t mode, int sparse) {
  PROTECT(
    auto outputs__ = torch::embedding_bag(*weight, *indices, *offsets, (bool)scale_grad_by_freq, mode, (bool)sparse);
    torch::Tensor **out__ = (torch::Tensor**)malloc(4*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    out__[3] = new torch::Tensor(std::get<3>(outputs__));
    return out__;
  )
}

tensor *atg_embedding_dense_backward(tensor grad, tensor indices, int64_t num_weights, int64_t padding_idx, int scale_grad_by_freq) {
  PROTECT(
    auto outputs__ = torch::embedding_dense_backward(*grad, *indices, num_weights, padding_idx, (bool)scale_grad_by_freq);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_embedding_renorm_(tensor self, tensor indices, double max_norm, double norm_type) {
  PROTECT(
    auto outputs__ = torch::embedding_renorm_(*self, *indices, max_norm, norm_type);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_embedding_sparse_backward(tensor grad, tensor indices, int64_t num_weights, int64_t padding_idx, int scale_grad_by_freq) {
  PROTECT(
    auto outputs__ = torch::embedding_sparse_backward(*grad, *indices, num_weights, padding_idx, (bool)scale_grad_by_freq);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_empty(int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::empty(torch::IntList(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_empty_like(tensor self) {
  PROTECT(
    auto outputs__ = torch::empty_like(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_empty_like1(tensor self, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::empty_like(*self, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_empty_out(tensor result, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::empty_out(*result, torch::IntList(size_data, size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_empty_strided(int64_t *size_data, int size_len, int64_t *stride_data, int stride_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::empty_strided(torch::IntList(size_data, size_len), torch::IntList(stride_data, stride_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_eq(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::eq(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_eq1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::eq(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_eq_(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->eq_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_eq_1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->eq_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_eq_out(tensor result, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::eq_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_eq_out1(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::eq_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_erf(tensor self) {
  PROTECT(
    auto outputs__ = torch::erf(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_erf_(tensor self) {
  PROTECT(
    auto outputs__ = torch::erf_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_erf_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::erf_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_erfc(tensor self) {
  PROTECT(
    auto outputs__ = torch::erfc(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_erfc_(tensor self) {
  PROTECT(
    auto outputs__ = torch::erfc_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_erfc_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::erfc_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_erfinv(tensor self) {
  PROTECT(
    auto outputs__ = torch::erfinv(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_erfinv_(tensor self) {
  PROTECT(
    auto outputs__ = self->erfinv_();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_erfinv_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::erfinv_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_exp(tensor self) {
  PROTECT(
    auto outputs__ = torch::exp(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_exp_(tensor self) {
  PROTECT(
    auto outputs__ = torch::exp_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_exp_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::exp_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_expand(tensor self, int64_t *size_data, int size_len, int implicit) {
  PROTECT(
    auto outputs__ = self->expand(torch::IntList(size_data, size_len), (bool)implicit);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_expand_as(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->expand_as(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_expm1(tensor self) {
  PROTECT(
    auto outputs__ = torch::expm1(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_expm1_(tensor self) {
  PROTECT(
    auto outputs__ = torch::expm1_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_expm1_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::expm1_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_exponential_(tensor self, double lambd) {
  PROTECT(
    auto outputs__ = self->exponential_(lambd);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_eye(int64_t n, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::eye(n, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_eye1(int64_t n, int64_t m, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::eye(n, m, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_eye_out(tensor result, int64_t n) {
  PROTECT(
    auto outputs__ = torch::eye_out(*result, n);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_eye_out1(tensor result, int64_t n, int64_t m) {
  PROTECT(
    auto outputs__ = torch::eye_out(*result, n, m);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_feature_alpha_dropout(tensor input, double p, int train) {
  PROTECT(
    auto outputs__ = torch::feature_alpha_dropout(*input, p, (bool)train);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_feature_alpha_dropout_(tensor self, double p, int train) {
  PROTECT(
    auto outputs__ = torch::feature_alpha_dropout_(*self, p, (bool)train);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_feature_dropout(tensor input, double p, int train) {
  PROTECT(
    auto outputs__ = torch::feature_dropout(*input, p, (bool)train);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_feature_dropout_(tensor self, double p, int train) {
  PROTECT(
    auto outputs__ = torch::feature_dropout_(*self, p, (bool)train);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fft(tensor self, int64_t signal_ndim, int normalized) {
  PROTECT(
    auto outputs__ = torch::fft(*self, signal_ndim, (bool)normalized);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fill_(tensor self, scalar value) {
  PROTECT(
    auto outputs__ = torch::fill_(*self, *value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fill_1(tensor self, tensor value) {
  PROTECT(
    auto outputs__ = torch::fill_(*self, *value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_flatten(tensor self, int64_t start_dim, int64_t end_dim) {
  PROTECT(
    auto outputs__ = torch::flatten(*self, start_dim, end_dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_flip(tensor self, int64_t *dims_data, int dims_len) {
  PROTECT(
    auto outputs__ = torch::flip(*self, torch::IntList(dims_data, dims_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_floor(tensor self) {
  PROTECT(
    auto outputs__ = torch::floor(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_floor_(tensor self) {
  PROTECT(
    auto outputs__ = torch::floor_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_floor_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::floor_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fmod(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::fmod(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fmod1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::fmod(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fmod_(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->fmod_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fmod_1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->fmod_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fmod_out(tensor result, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::fmod_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fmod_out1(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::fmod_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_frac(tensor self) {
  PROTECT(
    auto outputs__ = torch::frac(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_frac_(tensor self) {
  PROTECT(
    auto outputs__ = self->frac_();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_frac_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::frac_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fractional_max_pool2d(tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor random_samples) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool2d(*self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(output_size_data, output_size_len), *random_samples);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_fractional_max_pool2d_backward(tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor indices) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool2d_backward(*grad_output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(output_size_data, output_size_len), *indices);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fractional_max_pool2d_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor indices) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool2d_backward_out(*grad_input, *grad_output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(output_size_data, output_size_len), *indices);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_fractional_max_pool2d_out(tensor output, tensor indices, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor random_samples) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool2d_out(*output, *indices, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(output_size_data, output_size_len), *random_samples);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_frobenius_norm(tensor self) {
  PROTECT(
    auto outputs__ = torch::frobenius_norm(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_frobenius_norm1(tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::frobenius_norm(*self, torch::IntList(dim_data, dim_len), (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_frobenius_norm_out(tensor result, tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::frobenius_norm_out(*result, *self, torch::IntList(dim_data, dim_len), (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_full(int64_t *size_data, int size_len, scalar fill_value, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::full(torch::IntList(size_data, size_len), *fill_value, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_full_like(tensor self, scalar fill_value) {
  PROTECT(
    auto outputs__ = torch::full_like(*self, *fill_value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_full_like1(tensor self, scalar fill_value, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::full_like(*self, *fill_value, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_full_out(tensor result, int64_t *size_data, int size_len, scalar fill_value) {
  PROTECT(
    auto outputs__ = torch::full_out(*result, torch::IntList(size_data, size_len), *fill_value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_gather(tensor self, int64_t dim, tensor index) {
  PROTECT(
    auto outputs__ = torch::gather(*self, dim, *index);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_gather_out(tensor result, tensor self, int64_t dim, tensor index) {
  PROTECT(
    auto outputs__ = torch::gather_out(*result, *self, dim, *index);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ge(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::ge(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ge1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::ge(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ge_(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->ge_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ge_1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->ge_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ge_out(tensor result, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::ge_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ge_out1(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::ge_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_gels(tensor self, tensor A) {
  PROTECT(
    auto outputs__ = torch::gels(*self, *A);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_gels_out(tensor X, tensor qr, tensor self, tensor A) {
  PROTECT(
    auto outputs__ = torch::gels_out(*X, *qr, *self, *A);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_geometric_(tensor self, double p) {
  PROTECT(
    auto outputs__ = self->geometric_(p);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_geqrf(tensor self) {
  PROTECT(
    auto outputs__ = torch::geqrf(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_geqrf_out(tensor result0, tensor result1, tensor self) {
  PROTECT(
    auto outputs__ = torch::geqrf_out(*result0, *result1, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_ger(tensor self, tensor vec2) {
  PROTECT(
    auto outputs__ = torch::ger(*self, *vec2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ger_out(tensor result, tensor self, tensor vec2) {
  PROTECT(
    auto outputs__ = torch::ger_out(*result, *self, *vec2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_gesv(tensor self, tensor A) {
  PROTECT(
    auto outputs__ = torch::gesv(*self, *A);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_gesv_out(tensor solution, tensor lu, tensor self, tensor A) {
  PROTECT(
    auto outputs__ = torch::gesv_out(*solution, *lu, *self, *A);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_glu(tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::glu(*self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_glu_backward(tensor grad_output, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::glu_backward(*grad_output, *self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_glu_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::glu_backward_out(*grad_input, *grad_output, *self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_glu_out(tensor output, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::glu_out(*output, *self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_grad(tensor self) {
  PROTECT(
    auto outputs__ = self->grad();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_grid_sampler(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    auto outputs__ = torch::grid_sampler(*input, *grid, interpolation_mode, padding_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_grid_sampler_2d(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    auto outputs__ = torch::grid_sampler_2d(*input, *grid, interpolation_mode, padding_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_grid_sampler_2d_backward(tensor grad_output, tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    auto outputs__ = torch::grid_sampler_2d_backward(*grad_output, *input, *grid, interpolation_mode, padding_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_grid_sampler_3d(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    auto outputs__ = torch::grid_sampler_3d(*input, *grid, interpolation_mode, padding_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_grid_sampler_3d_backward(tensor grad_output, tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    auto outputs__ = torch::grid_sampler_3d_backward(*grad_output, *input, *grid, interpolation_mode, padding_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_group_norm(tensor input, int64_t num_groups, tensor weight, tensor bias, double eps, int cudnn_enabled) {
  PROTECT(
    auto outputs__ = torch::group_norm(*input, num_groups, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), eps, (bool)cudnn_enabled);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_gru(tensor input, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional, int batch_first) {
  PROTECT(
    auto outputs__ = torch::gru(*input, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional, (bool)batch_first);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_gru1(tensor data, tensor batch_sizes, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional) {
  PROTECT(
    auto outputs__ = torch::gru(*data, *batch_sizes, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_gru_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh) {
  PROTECT(
    auto outputs__ = torch::gru_cell(*input, *hx, *w_ih, *w_hh, (b_ih ? *b_ih : torch::Tensor()), (b_hh ? *b_hh : torch::Tensor()));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_gt(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::gt(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_gt1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::gt(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_gt_(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->gt_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_gt_1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->gt_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_gt_out(tensor result, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::gt_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_gt_out1(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::gt_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hamming_window(int64_t window_length, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hamming_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hamming_window1(int64_t window_length, int periodic, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hamming_window(window_length, (bool)periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hamming_window2(int64_t window_length, int periodic, double alpha, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hamming_window(window_length, (bool)periodic, alpha, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hamming_window3(int64_t window_length, int periodic, double alpha, double beta, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hamming_window(window_length, (bool)periodic, alpha, beta, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hann_window(int64_t window_length, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hann_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hann_window1(int64_t window_length, int periodic, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hann_window(window_length, (bool)periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hardshrink(tensor self) {
  PROTECT(
    auto outputs__ = torch::hardshrink(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hardshrink_backward(tensor grad_out, tensor self, scalar lambd) {
  PROTECT(
    auto outputs__ = torch::hardshrink_backward(*grad_out, *self, *lambd);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hardtanh(tensor self) {
  PROTECT(
    auto outputs__ = torch::hardtanh(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hardtanh_(tensor self) {
  PROTECT(
    auto outputs__ = torch::hardtanh_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hardtanh_out(tensor output, tensor self) {
  PROTECT(
    auto outputs__ = torch::hardtanh_out(*output, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hinge_embedding_loss(tensor self, tensor target, double margin, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::hinge_embedding_loss(*self, *target, margin, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_histc(tensor self, int64_t bins) {
  PROTECT(
    auto outputs__ = torch::histc(*self, bins);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_histc_out(tensor result, tensor self, int64_t bins) {
  PROTECT(
    auto outputs__ = torch::histc_out(*result, *self, bins);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hspmm(tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::hspmm(*mat1, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_hspmm_out(tensor result, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::hspmm_out(*result, *mat1, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ifft(tensor self, int64_t signal_ndim, int normalized) {
  PROTECT(
    auto outputs__ = torch::ifft(*self, signal_ndim, (bool)normalized);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_index(tensor self, tensor *indices_data, int indices_len) {
  PROTECT(
    auto outputs__ = torch::index(*self, of_carray_tensor(indices_data, indices_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_index_add_(tensor self, int64_t dim, tensor index, tensor source) {
  PROTECT(
    auto outputs__ = self->index_add_(dim, *index, *source);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_index_copy_(tensor self, int64_t dim, tensor index, tensor source) {
  PROTECT(
    auto outputs__ = self->index_copy_(dim, *index, *source);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_index_fill_(tensor self, int64_t dim, tensor index, scalar value) {
  PROTECT(
    auto outputs__ = self->index_fill_(dim, *index, *value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_index_fill_1(tensor self, int64_t dim, tensor index, tensor value) {
  PROTECT(
    auto outputs__ = self->index_fill_(dim, *index, *value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_index_put(tensor self, tensor *indices_data, int indices_len, tensor values) {
  PROTECT(
    auto outputs__ = torch::index_put(*self, of_carray_tensor(indices_data, indices_len), *values);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_index_put_(tensor self, tensor *indices_data, int indices_len, tensor values) {
  PROTECT(
    auto outputs__ = torch::index_put_(*self, of_carray_tensor(indices_data, indices_len), *values);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_index_select(tensor self, int64_t dim, tensor index) {
  PROTECT(
    auto outputs__ = torch::index_select(*self, dim, *index);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_index_select_out(tensor result, tensor self, int64_t dim, tensor index) {
  PROTECT(
    auto outputs__ = torch::index_select_out(*result, *self, dim, *index);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_indices(tensor self) {
  PROTECT(
    auto outputs__ = self->indices();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_instance_norm(tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int use_input_stats, double momentum, double eps, int cudnn_enabled) {
  PROTECT(
    auto outputs__ = torch::instance_norm(*input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)use_input_stats, momentum, eps, (bool)cudnn_enabled);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_inverse(tensor self) {
  PROTECT(
    auto outputs__ = torch::inverse(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_inverse_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::inverse_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_irfft(tensor self, int64_t signal_ndim, int normalized, int onesided, int64_t *signal_sizes_data, int signal_sizes_len) {
  PROTECT(
    auto outputs__ = torch::irfft(*self, signal_ndim, (bool)normalized, (bool)onesided, torch::IntList(signal_sizes_data, signal_sizes_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_isclose(tensor self, tensor other, double rtol, double atol, int equal_nan) {
  PROTECT(
    auto outputs__ = torch::isclose(*self, *other, rtol, atol, (bool)equal_nan);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_kl_div(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::kl_div(*self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_kl_div_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::kl_div_backward(*grad_output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_kthvalue(tensor self, int64_t k, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::kthvalue(*self, k, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_kthvalue_out(tensor values, tensor indices, tensor self, int64_t k, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::kthvalue_out(*values, *indices, *self, k, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_l1_loss(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::l1_loss(*self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_l1_loss_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::l1_loss_backward(*grad_output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_l1_loss_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::l1_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_l1_loss_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::l1_loss_out(*output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_layer_norm(tensor input, int64_t *normalized_shape_data, int normalized_shape_len, tensor weight, tensor bias, double eps, int cudnn_enable) {
  PROTECT(
    auto outputs__ = torch::layer_norm(*input, torch::IntList(normalized_shape_data, normalized_shape_len), (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), eps, (bool)cudnn_enable);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_le(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::le(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_le1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::le(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_le_(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->le_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_le_1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->le_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_le_out(tensor result, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::le_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_le_out1(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::le_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_leaky_relu(tensor self) {
  PROTECT(
    auto outputs__ = torch::leaky_relu(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_leaky_relu_(tensor self) {
  PROTECT(
    auto outputs__ = torch::leaky_relu_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_leaky_relu_out(tensor output, tensor self) {
  PROTECT(
    auto outputs__ = torch::leaky_relu_out(*output, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lerp(tensor self, tensor end, scalar weight) {
  PROTECT(
    auto outputs__ = torch::lerp(*self, *end, *weight);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lerp_(tensor self, tensor end, scalar weight) {
  PROTECT(
    auto outputs__ = self->lerp_(*end, *weight);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lerp_out(tensor result, tensor self, tensor end, scalar weight) {
  PROTECT(
    auto outputs__ = torch::lerp_out(*result, *self, *end, *weight);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lgamma(tensor self) {
  PROTECT(
    auto outputs__ = torch::lgamma(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lgamma_(tensor self) {
  PROTECT(
    auto outputs__ = self->lgamma_();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lgamma_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::lgamma_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_linear(tensor input, tensor weight, tensor bias) {
  PROTECT(
    auto outputs__ = torch::linear(*input, *weight, *bias);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_linspace(scalar start, scalar end, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::linspace(*start, *end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_linspace1(scalar start, scalar end, int64_t steps, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::linspace(*start, *end, steps, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_linspace_out(tensor result, scalar start, scalar end) {
  PROTECT(
    auto outputs__ = torch::linspace_out(*result, *start, *end);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_linspace_out1(tensor result, scalar start, scalar end, int64_t steps) {
  PROTECT(
    auto outputs__ = torch::linspace_out(*result, *start, *end, steps);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log(tensor self) {
  PROTECT(
    auto outputs__ = torch::log(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log10(tensor self) {
  PROTECT(
    auto outputs__ = torch::log10(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log10_(tensor self) {
  PROTECT(
    auto outputs__ = torch::log10_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log10_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::log10_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log1p(tensor self) {
  PROTECT(
    auto outputs__ = torch::log1p(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log1p_(tensor self) {
  PROTECT(
    auto outputs__ = torch::log1p_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log1p_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::log1p_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log2(tensor self) {
  PROTECT(
    auto outputs__ = torch::log2(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log2_(tensor self) {
  PROTECT(
    auto outputs__ = torch::log2_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log2_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::log2_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log_(tensor self) {
  PROTECT(
    auto outputs__ = torch::log_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log_normal_(tensor self, double mean, double std) {
  PROTECT(
    auto outputs__ = self->log_normal_(mean, std);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::log_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log_sigmoid(tensor self) {
  PROTECT(
    auto outputs__ = torch::log_sigmoid(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log_sigmoid_backward(tensor grad_output, tensor self, tensor buffer) {
  PROTECT(
    auto outputs__ = torch::log_sigmoid_backward(*grad_output, *self, *buffer);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log_sigmoid_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor buffer) {
  PROTECT(
    auto outputs__ = torch::log_sigmoid_backward_out(*grad_input, *grad_output, *self, *buffer);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log_sigmoid_out(tensor output, tensor self) {
  PROTECT(
    auto outputs__ = torch::log_sigmoid_out(*output, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log_softmax(tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::log_softmax(*self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_log_softmax1(tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::log_softmax(*self, dim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_logdet(tensor self) {
  PROTECT(
    auto outputs__ = torch::logdet(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_logspace(scalar start, scalar end, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::logspace(*start, *end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_logspace1(scalar start, scalar end, int64_t steps, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::logspace(*start, *end, steps, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_logspace_out(tensor result, scalar start, scalar end) {
  PROTECT(
    auto outputs__ = torch::logspace_out(*result, *start, *end);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_logspace_out1(tensor result, scalar start, scalar end, int64_t steps) {
  PROTECT(
    auto outputs__ = torch::logspace_out(*result, *start, *end, steps);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_logsumexp(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::logsumexp(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_logsumexp_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::logsumexp_out(*result, *self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lstm(tensor input, tensor *hx_data, int hx_len, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional, int batch_first) {
  PROTECT(
    auto outputs__ = torch::lstm(*input, of_carray_tensor(hx_data, hx_len), of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional, (bool)batch_first);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_lstm1(tensor data, tensor batch_sizes, tensor *hx_data, int hx_len, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional) {
  PROTECT(
    auto outputs__ = torch::lstm(*data, *batch_sizes, of_carray_tensor(hx_data, hx_len), of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_lstm_cell(tensor input, tensor *hx_data, int hx_len, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh) {
  PROTECT(
    auto outputs__ = torch::lstm_cell(*input, of_carray_tensor(hx_data, hx_len), *w_ih, *w_hh, (b_ih ? *b_ih : torch::Tensor()), (b_hh ? *b_hh : torch::Tensor()));
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_lt(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::lt(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lt1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::lt(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lt_(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->lt_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lt_1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->lt_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lt_out(tensor result, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::lt_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_lt_out1(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::lt_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_margin_ranking_loss(tensor input1, tensor input2, tensor target, double margin, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::margin_ranking_loss(*input1, *input2, *target, margin, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_masked_fill_(tensor self, tensor mask, scalar value) {
  PROTECT(
    auto outputs__ = self->masked_fill_(*mask, *value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_masked_fill_1(tensor self, tensor mask, tensor value) {
  PROTECT(
    auto outputs__ = self->masked_fill_(*mask, *value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_masked_scatter_(tensor self, tensor mask, tensor source) {
  PROTECT(
    auto outputs__ = self->masked_scatter_(*mask, *source);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_masked_select(tensor self, tensor mask) {
  PROTECT(
    auto outputs__ = torch::masked_select(*self, *mask);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_masked_select_out(tensor result, tensor self, tensor mask) {
  PROTECT(
    auto outputs__ = torch::masked_select_out(*result, *self, *mask);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_matmul(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::matmul(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_matmul_out(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::matmul_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_matrix_power(tensor self, int64_t n) {
  PROTECT(
    auto outputs__ = torch::matrix_power(*self, n);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_matrix_rank(tensor self, int symmetric) {
  PROTECT(
    auto outputs__ = torch::matrix_rank(*self, (bool)symmetric);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_matrix_rank1(tensor self, double tol, int symmetric) {
  PROTECT(
    auto outputs__ = torch::matrix_rank(*self, tol, (bool)symmetric);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max(tensor self) {
  PROTECT(
    auto outputs__ = torch::max(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::max(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max2(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::max(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_max_out(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::max_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_out1(tensor max, tensor max_values, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::max_out(*max, *max_values, *self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_max_pool1d(tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool1d(*self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_pool1d_with_indices(tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool1d_with_indices(*self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_max_pool2d(tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool2d(*self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_pool2d_with_indices(tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool2d_with_indices(*self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_max_pool2d_with_indices_backward(tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode, tensor indices) {
  PROTECT(
    auto outputs__ = torch::max_pool2d_with_indices_backward(*grad_output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode, *indices);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_pool2d_with_indices_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode, tensor indices) {
  PROTECT(
    auto outputs__ = torch::max_pool2d_with_indices_backward_out(*grad_input, *grad_output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode, *indices);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_pool2d_with_indices_out(tensor output, tensor indices, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool2d_with_indices_out(*output, *indices, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_max_pool3d(tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool3d(*self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_pool3d_with_indices(tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool3d_with_indices(*self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_max_pool3d_with_indices_backward(tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode, tensor indices) {
  PROTECT(
    auto outputs__ = torch::max_pool3d_with_indices_backward(*grad_output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode, *indices);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_pool3d_with_indices_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode, tensor indices) {
  PROTECT(
    auto outputs__ = torch::max_pool3d_with_indices_backward_out(*grad_input, *grad_output, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode, *indices);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_pool3d_with_indices_out(tensor output, tensor indices, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool3d_with_indices_out(*output, *indices, *self, torch::IntList(kernel_size_data, kernel_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len), torch::IntList(dilation_data, dilation_len), (bool)ceil_mode);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_max_unpool2d(tensor self, tensor indices, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool2d(*self, *indices, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_unpool2d_backward(tensor grad_output, tensor self, tensor indices, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool2d_backward(*grad_output, *self, *indices, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_unpool2d_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor indices, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool2d_backward_out(*grad_input, *grad_output, *self, *indices, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_unpool2d_out(tensor output, tensor self, tensor indices, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool2d_out(*output, *self, *indices, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_unpool3d(tensor self, tensor indices, int64_t *output_size_data, int output_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool3d(*self, *indices, torch::IntList(output_size_data, output_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_unpool3d_backward(tensor grad_output, tensor self, tensor indices, int64_t *output_size_data, int output_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool3d_backward(*grad_output, *self, *indices, torch::IntList(output_size_data, output_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_unpool3d_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor indices, int64_t *output_size_data, int output_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool3d_backward_out(*grad_input, *grad_output, *self, *indices, torch::IntList(output_size_data, output_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_unpool3d_out(tensor output, tensor self, tensor indices, int64_t *output_size_data, int output_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool3d_out(*output, *self, *indices, torch::IntList(output_size_data, output_size_len), torch::IntList(stride_data, stride_len), torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_max_values(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::max_values(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mean(tensor self) {
  PROTECT(
    auto outputs__ = torch::mean(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mean1(tensor self, int dtype) {
  PROTECT(
    auto outputs__ = torch::mean(*self, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mean2(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::mean(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mean3(tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::mean(*self, dim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mean4(tensor self, int64_t dim, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::mean(*self, dim, (bool)keepdim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mean_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::mean_out(*result, *self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mean_out1(tensor result, tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::mean_out(*result, *self, dim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mean_out2(tensor result, tensor self, int64_t dim, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::mean_out(*result, *self, dim, (bool)keepdim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_median(tensor self) {
  PROTECT(
    auto outputs__ = torch::median(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_median1(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::median(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_median_out(tensor values, tensor indices, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::median_out(*values, *indices, *self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_meshgrid(tensor *tensors_data, int tensors_len) {
  PROTECT(
    auto outputs__ = torch::meshgrid(of_carray_tensor(tensors_data, tensors_len));
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
}

tensor *atg_min(tensor self) {
  PROTECT(
    auto outputs__ = torch::min(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_min1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::min(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_min2(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::min(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_min_out(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::min_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_min_out1(tensor min, tensor min_indices, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::min_out(*min, *min_indices, *self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_min_values(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::min_values(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_miopen_batch_norm(tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double exponential_average_factor, double epsilon) {
  PROTECT(
    auto outputs__ = torch::miopen_batch_norm(*input, *weight, (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)training, exponential_average_factor, epsilon);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_miopen_batch_norm_backward(tensor input, tensor grad_output, tensor weight, tensor running_mean, tensor running_var, tensor save_mean, tensor save_var, double epsilon) {
  PROTECT(
    auto outputs__ = torch::miopen_batch_norm_backward(*input, *grad_output, *weight, (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (save_mean ? *save_mean : torch::Tensor()), (save_var ? *save_var : torch::Tensor()), epsilon);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_miopen_convolution(tensor self, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution(*self, *weight, (bias ? *bias : torch::Tensor()), torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_miopen_convolution_backward_bias(tensor grad_output) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_backward_bias(*grad_output);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_miopen_convolution_backward_input(int64_t *self_size_data, int self_size_len, tensor grad_output, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_backward_input(torch::IntList(self_size_data, self_size_len), *grad_output, *weight, torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_miopen_convolution_backward_weight(int64_t *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_backward_weight(torch::IntList(weight_size_data, weight_size_len), *grad_output, *self, torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_miopen_convolution_transpose(tensor self, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_transpose(*self, *weight, (bias ? *bias : torch::Tensor()), torch::IntList(padding_data, padding_len), torch::IntList(output_padding_data, output_padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_miopen_convolution_transpose_backward_input(tensor grad_output, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_transpose_backward_input(*grad_output, *weight, torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_miopen_convolution_transpose_backward_weight(int64_t *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_transpose_backward_weight(torch::IntList(weight_size_data, weight_size_len), *grad_output, *self, torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mkldnn_convolution(tensor self, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::mkldnn_convolution(*self, *weight, (bias ? *bias : torch::Tensor()), torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mkldnn_convolution_backward_input(int64_t *self_size_data, int self_size_len, tensor grad_output, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int bias_defined) {
  PROTECT(
    auto outputs__ = torch::mkldnn_convolution_backward_input(torch::IntList(self_size_data, self_size_len), *grad_output, *weight, torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)bias_defined);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mkldnn_convolution_backward_weights(int64_t *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int bias_defined) {
  PROTECT(
    auto outputs__ = torch::mkldnn_convolution_backward_weights(torch::IntList(weight_size_data, weight_size_len), *grad_output, *self, torch::IntList(padding_data, padding_len), torch::IntList(stride_data, stride_len), torch::IntList(dilation_data, dilation_len), groups, (bool)bias_defined);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_mm(tensor self, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::mm(*self, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mm_out(tensor result, tensor self, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::mm_out(*result, *self, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mode(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::mode(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_mode_out(tensor values, tensor indices, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::mode_out(*values, *indices, *self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_mse_loss(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::mse_loss(*self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mse_loss_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::mse_loss_backward(*grad_output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mse_loss_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::mse_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mse_loss_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::mse_loss_out(*output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mul(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::mul(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mul1(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::mul(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mul_(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->mul_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mul_1(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->mul_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mul_out(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::mul_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_multilabel_margin_loss(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::multilabel_margin_loss(*self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_multilabel_margin_loss_backward(tensor grad_output, tensor self, tensor target, int64_t reduction, tensor is_target) {
  PROTECT(
    auto outputs__ = torch::multilabel_margin_loss_backward(*grad_output, *self, *target, reduction, *is_target);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_multilabel_margin_loss_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction, tensor is_target) {
  PROTECT(
    auto outputs__ = torch::multilabel_margin_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction, *is_target);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_multilabel_margin_loss_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::multilabel_margin_loss_out(*output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_multinomial(tensor self, int64_t num_samples, int replacement) {
  PROTECT(
    auto outputs__ = torch::multinomial(*self, num_samples, (bool)replacement);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_multinomial_out(tensor result, tensor self, int64_t num_samples, int replacement) {
  PROTECT(
    auto outputs__ = torch::multinomial_out(*result, *self, num_samples, (bool)replacement);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mv(tensor self, tensor vec) {
  PROTECT(
    auto outputs__ = torch::mv(*self, *vec);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mv_out(tensor result, tensor self, tensor vec) {
  PROTECT(
    auto outputs__ = torch::mv_out(*result, *self, *vec);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mvlgamma(tensor self, int64_t p) {
  PROTECT(
    auto outputs__ = torch::mvlgamma(*self, p);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_mvlgamma_(tensor self, int64_t p) {
  PROTECT(
    auto outputs__ = self->mvlgamma_(p);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_narrow(tensor self, int64_t dim, int64_t start, int64_t length) {
  PROTECT(
    auto outputs__ = torch::narrow(*self, dim, start, length);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_narrow_copy(tensor self, int64_t dim, int64_t start, int64_t length) {
  PROTECT(
    auto outputs__ = self->narrow_copy(dim, start, length);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_native_batch_norm(tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double momentum, double eps) {
  PROTECT(
    auto outputs__ = torch::native_batch_norm(*input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)training, momentum, eps);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_native_clone(tensor self) {
  PROTECT(
    auto outputs__ = torch::native_clone(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_native_norm(tensor self) {
  PROTECT(
    auto outputs__ = torch::native_norm(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_native_pow(tensor self, scalar exponent) {
  PROTECT(
    auto outputs__ = torch::native_pow(*self, *exponent);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_native_pow_out(tensor result, tensor self, scalar exponent) {
  PROTECT(
    auto outputs__ = torch::native_pow_out(*result, *self, *exponent);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_native_resize_as_(tensor self, tensor the_template) {
  PROTECT(
    auto outputs__ = torch::native_resize_as_(*self, *the_template);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_native_zero_(tensor self) {
  PROTECT(
    auto outputs__ = torch::native_zero_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ne(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::ne(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ne1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::ne(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ne_(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->ne_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ne_1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->ne_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ne_out(tensor result, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::ne_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ne_out1(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::ne_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_neg(tensor self) {
  PROTECT(
    auto outputs__ = torch::neg(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_neg_(tensor self) {
  PROTECT(
    auto outputs__ = self->neg_();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_neg_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::neg_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nll_loss(tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index) {
  PROTECT(
    auto outputs__ = torch::nll_loss(*self, *target, *weight, reduction, ignore_index);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nll_loss2d(tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index) {
  PROTECT(
    auto outputs__ = torch::nll_loss2d(*self, *target, *weight, reduction, ignore_index);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nll_loss2d_backward(tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index, tensor total_weight) {
  PROTECT(
    auto outputs__ = torch::nll_loss2d_backward(*grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index, *total_weight);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nll_loss2d_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index, tensor total_weight) {
  PROTECT(
    auto outputs__ = torch::nll_loss2d_backward_out(*grad_input, *grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index, *total_weight);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nll_loss2d_out(tensor output, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index) {
  PROTECT(
    auto outputs__ = torch::nll_loss2d_out(*output, *self, *target, *weight, reduction, ignore_index);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nll_loss_backward(tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index, tensor total_weight) {
  PROTECT(
    auto outputs__ = torch::nll_loss_backward(*grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index, *total_weight);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nll_loss_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index, tensor total_weight) {
  PROTECT(
    auto outputs__ = torch::nll_loss_backward_out(*grad_input, *grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index, *total_weight);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nll_loss_out(tensor output, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index) {
  PROTECT(
    auto outputs__ = torch::nll_loss_out(*output, *self, *target, *weight, reduction, ignore_index);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nonzero(tensor self) {
  PROTECT(
    auto outputs__ = torch::nonzero(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nonzero_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::nonzero_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_norm(tensor self) {
  PROTECT(
    auto outputs__ = torch::norm(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_norm1(tensor self, scalar p, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::norm(*self, *p, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_norm_except_dim(tensor v, int64_t pow, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::norm_except_dim(*v, pow, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_norm_out(tensor result, tensor self, scalar p, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::norm_out(*result, *self, *p, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_normal(tensor mean, double std) {
  PROTECT(
    auto outputs__ = torch::normal(*mean, std);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_normal1(double mean, tensor std) {
  PROTECT(
    auto outputs__ = torch::normal(mean, *std);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_normal2(tensor mean, tensor std) {
  PROTECT(
    auto outputs__ = torch::normal(*mean, *std);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_normal_(tensor self, double mean, double std) {
  PROTECT(
    auto outputs__ = self->normal_(mean, std);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_normal_out(tensor output, tensor mean, double std) {
  PROTECT(
    auto outputs__ = torch::normal_out(*output, *mean, std);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_normal_out1(tensor output, double mean, tensor std) {
  PROTECT(
    auto outputs__ = torch::normal_out(*output, mean, *std);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_normal_out2(tensor output, tensor mean, tensor std) {
  PROTECT(
    auto outputs__ = torch::normal_out(*output, *mean, *std);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nuclear_norm(tensor self, int keepdim) {
  PROTECT(
    auto outputs__ = torch::nuclear_norm(*self, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_nuclear_norm_out(tensor result, tensor self, int keepdim) {
  PROTECT(
    auto outputs__ = torch::nuclear_norm_out(*result, *self, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ones(int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::ones(torch::IntList(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ones_like(tensor self) {
  PROTECT(
    auto outputs__ = torch::ones_like(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ones_like1(tensor self, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::ones_like(*self, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ones_out(tensor result, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::ones_out(*result, torch::IntList(size_data, size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_orgqr(tensor self, tensor input2) {
  PROTECT(
    auto outputs__ = torch::orgqr(*self, *input2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_orgqr_out(tensor result, tensor self, tensor input2) {
  PROTECT(
    auto outputs__ = torch::orgqr_out(*result, *self, *input2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ormqr(tensor self, tensor input2, tensor input3, int left, int transpose) {
  PROTECT(
    auto outputs__ = torch::ormqr(*self, *input2, *input3, (bool)left, (bool)transpose);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_ormqr_out(tensor result, tensor self, tensor input2, tensor input3, int left, int transpose) {
  PROTECT(
    auto outputs__ = torch::ormqr_out(*result, *self, *input2, *input3, (bool)left, (bool)transpose);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pairwise_distance(tensor x1, tensor x2, double p, double eps, int keepdim) {
  PROTECT(
    auto outputs__ = torch::pairwise_distance(*x1, *x2, p, eps, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pdist(tensor self, double p) {
  PROTECT(
    auto outputs__ = torch::pdist(*self, p);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_permute(tensor self, int64_t *dims_data, int dims_len) {
  PROTECT(
    auto outputs__ = self->permute(torch::IntList(dims_data, dims_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pin_memory(tensor self) {
  PROTECT(
    auto outputs__ = torch::pin_memory(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pinverse(tensor self, double rcond) {
  PROTECT(
    auto outputs__ = torch::pinverse(*self, rcond);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pixel_shuffle(tensor self, int64_t upscale_factor) {
  PROTECT(
    auto outputs__ = torch::pixel_shuffle(*self, upscale_factor);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_poisson(tensor self) {
  PROTECT(
    auto outputs__ = torch::poisson(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_polygamma(int64_t n, tensor self) {
  PROTECT(
    auto outputs__ = torch::polygamma(n, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_polygamma_(tensor self, int64_t n) {
  PROTECT(
    auto outputs__ = self->polygamma_(n);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_polygamma_out(tensor result, int64_t n, tensor self) {
  PROTECT(
    auto outputs__ = torch::polygamma_out(*result, n, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_potri(tensor self, int upper) {
  PROTECT(
    auto outputs__ = torch::potri(*self, (bool)upper);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_potri_out(tensor result, tensor self, int upper) {
  PROTECT(
    auto outputs__ = torch::potri_out(*result, *self, (bool)upper);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_potrs(tensor self, tensor input2, int upper) {
  PROTECT(
    auto outputs__ = torch::potrs(*self, *input2, (bool)upper);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_potrs_out(tensor result, tensor self, tensor input2, int upper) {
  PROTECT(
    auto outputs__ = torch::potrs_out(*result, *self, *input2, (bool)upper);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pow(tensor self, scalar exponent) {
  PROTECT(
    auto outputs__ = torch::pow(*self, *exponent);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pow1(tensor self, tensor exponent) {
  PROTECT(
    auto outputs__ = torch::pow(*self, *exponent);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pow2(scalar self_scalar, tensor exponent) {
  PROTECT(
    auto outputs__ = torch::pow(*self_scalar, *exponent);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pow_(tensor self, scalar exponent) {
  PROTECT(
    auto outputs__ = self->pow_(*exponent);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pow_1(tensor self, tensor exponent) {
  PROTECT(
    auto outputs__ = self->pow_(*exponent);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pow_out(tensor result, tensor self, scalar exponent) {
  PROTECT(
    auto outputs__ = torch::pow_out(*result, *self, *exponent);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pow_out1(tensor result, tensor self, tensor exponent) {
  PROTECT(
    auto outputs__ = torch::pow_out(*result, *self, *exponent);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pow_out2(tensor result, scalar self_scalar, tensor exponent) {
  PROTECT(
    auto outputs__ = torch::pow_out(*result, *self_scalar, *exponent);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_prelu(tensor self, tensor weight) {
  PROTECT(
    auto outputs__ = torch::prelu(*self, *weight);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_prelu_backward(tensor grad_output, tensor self, tensor weight) {
  PROTECT(
    auto outputs__ = torch::prelu_backward(*grad_output, *self, *weight);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_prod(tensor self) {
  PROTECT(
    auto outputs__ = torch::prod(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_prod1(tensor self, int dtype) {
  PROTECT(
    auto outputs__ = torch::prod(*self, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_prod2(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::prod(*self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_prod3(tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::prod(*self, dim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_prod4(tensor self, int64_t dim, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::prod(*self, dim, (bool)keepdim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_prod_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::prod_out(*result, *self, dim, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_prod_out1(tensor result, tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::prod_out(*result, *self, dim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_prod_out2(tensor result, tensor self, int64_t dim, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::prod_out(*result, *self, dim, (bool)keepdim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_pstrf(tensor self, int upper) {
  PROTECT(
    auto outputs__ = torch::pstrf(*self, (bool)upper);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_pstrf_out(tensor u, tensor piv, tensor self, int upper) {
  PROTECT(
    auto outputs__ = torch::pstrf_out(*u, *piv, *self, (bool)upper);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_put_(tensor self, tensor index, tensor source, int accumulate) {
  PROTECT(
    auto outputs__ = self->put_(*index, *source, (bool)accumulate);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_qr(tensor self) {
  PROTECT(
    auto outputs__ = torch::qr(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_qr_out(tensor Q, tensor R, tensor self) {
  PROTECT(
    auto outputs__ = torch::qr_out(*Q, *R, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_rand(int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::rand(torch::IntList(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rand_like(tensor self) {
  PROTECT(
    auto outputs__ = torch::rand_like(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rand_like1(tensor self, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::rand_like(*self, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rand_out(tensor result, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::rand_out(*result, torch::IntList(size_data, size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randint(int64_t high, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::randint(high, torch::IntList(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randint1(int64_t low, int64_t high, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::randint(low, high, torch::IntList(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randint_like(tensor self, int64_t high) {
  PROTECT(
    auto outputs__ = torch::randint_like(*self, high);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randint_like1(tensor self, int64_t low, int64_t high) {
  PROTECT(
    auto outputs__ = torch::randint_like(*self, low, high);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randint_like2(tensor self, int64_t high, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::randint_like(*self, high, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randint_like3(tensor self, int64_t low, int64_t high, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::randint_like(*self, low, high, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randint_out(tensor result, int64_t high, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::randint_out(*result, high, torch::IntList(size_data, size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randint_out1(tensor result, int64_t low, int64_t high, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::randint_out(*result, low, high, torch::IntList(size_data, size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randn(int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::randn(torch::IntList(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randn_like(tensor self) {
  PROTECT(
    auto outputs__ = torch::randn_like(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randn_like1(tensor self, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::randn_like(*self, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randn_out(tensor result, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::randn_out(*result, torch::IntList(size_data, size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_random_(tensor self) {
  PROTECT(
    auto outputs__ = self->random_();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_random_1(tensor self, int64_t to) {
  PROTECT(
    auto outputs__ = self->random_(to);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_random_2(tensor self, int64_t from, int64_t to) {
  PROTECT(
    auto outputs__ = self->random_(from, to);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randperm(int64_t n, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::randperm(n, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_randperm_out(tensor result, int64_t n) {
  PROTECT(
    auto outputs__ = torch::randperm_out(*result, n);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_range(scalar start, scalar end, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::range(*start, *end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_range1(scalar start, scalar end, scalar step, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::range(*start, *end, *step, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_range_out(tensor result, scalar start, scalar end) {
  PROTECT(
    auto outputs__ = torch::range_out(*result, *start, *end);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_range_out1(tensor result, scalar start, scalar end, scalar step) {
  PROTECT(
    auto outputs__ = torch::range_out(*result, *start, *end, *step);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reciprocal(tensor self) {
  PROTECT(
    auto outputs__ = torch::reciprocal(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reciprocal_(tensor self) {
  PROTECT(
    auto outputs__ = self->reciprocal_();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reciprocal_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::reciprocal_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reflection_pad1d(tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad1d(*self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reflection_pad1d_backward(tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad1d_backward(*grad_output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reflection_pad1d_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad1d_backward_out(*grad_input, *grad_output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reflection_pad1d_out(tensor output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad1d_out(*output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reflection_pad2d(tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad2d(*self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reflection_pad2d_backward(tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad2d_backward(*grad_output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reflection_pad2d_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad2d_backward_out(*grad_input, *grad_output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reflection_pad2d_out(tensor output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad2d_out(*output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_relu(tensor self) {
  PROTECT(
    auto outputs__ = torch::relu(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_relu_(tensor self) {
  PROTECT(
    auto outputs__ = torch::relu_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_remainder(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::remainder(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_remainder1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::remainder(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_remainder_(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->remainder_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_remainder_1(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->remainder_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_remainder_out(tensor result, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::remainder_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_remainder_out1(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::remainder_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_renorm(tensor self, scalar p, int64_t dim, scalar maxnorm) {
  PROTECT(
    auto outputs__ = torch::renorm(*self, *p, dim, *maxnorm);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_renorm_(tensor self, scalar p, int64_t dim, scalar maxnorm) {
  PROTECT(
    auto outputs__ = self->renorm_(*p, dim, *maxnorm);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_renorm_out(tensor result, tensor self, scalar p, int64_t dim, scalar maxnorm) {
  PROTECT(
    auto outputs__ = torch::renorm_out(*result, *self, *p, dim, *maxnorm);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_repeat(tensor self, int64_t *repeats_data, int repeats_len) {
  PROTECT(
    auto outputs__ = self->repeat(torch::IntList(repeats_data, repeats_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad1d(tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad1d(*self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad1d_backward(tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad1d_backward(*grad_output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad1d_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad1d_backward_out(*grad_input, *grad_output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad1d_out(tensor output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad1d_out(*output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad2d(tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad2d(*self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad2d_backward(tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad2d_backward(*grad_output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad2d_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad2d_backward_out(*grad_input, *grad_output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad2d_out(tensor output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad2d_out(*output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad3d(tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad3d(*self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad3d_backward(tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad3d_backward(*grad_output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad3d_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad3d_backward_out(*grad_input, *grad_output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_replication_pad3d_out(tensor output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad3d_out(*output, *self, torch::IntList(padding_data, padding_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reshape(tensor self, int64_t *shape_data, int shape_len) {
  PROTECT(
    auto outputs__ = torch::reshape(*self, torch::IntList(shape_data, shape_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_reshape_as(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->reshape_as(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_resize_(tensor self, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = self->resize_(torch::IntList(size_data, size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_resize_as_(tensor self, tensor the_template) {
  PROTECT(
    auto outputs__ = torch::resize_as_(*self, *the_template);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rfft(tensor self, int64_t signal_ndim, int normalized, int onesided) {
  PROTECT(
    auto outputs__ = torch::rfft(*self, signal_ndim, (bool)normalized, (bool)onesided);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rnn_relu(tensor input, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional, int batch_first) {
  PROTECT(
    auto outputs__ = torch::rnn_relu(*input, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional, (bool)batch_first);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_rnn_relu1(tensor data, tensor batch_sizes, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional) {
  PROTECT(
    auto outputs__ = torch::rnn_relu(*data, *batch_sizes, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_rnn_relu_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh) {
  PROTECT(
    auto outputs__ = torch::rnn_relu_cell(*input, *hx, *w_ih, *w_hh, (b_ih ? *b_ih : torch::Tensor()), (b_hh ? *b_hh : torch::Tensor()));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rnn_tanh(tensor input, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional, int batch_first) {
  PROTECT(
    auto outputs__ = torch::rnn_tanh(*input, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional, (bool)batch_first);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_rnn_tanh1(tensor data, tensor batch_sizes, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional) {
  PROTECT(
    auto outputs__ = torch::rnn_tanh(*data, *batch_sizes, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_rnn_tanh_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh) {
  PROTECT(
    auto outputs__ = torch::rnn_tanh_cell(*input, *hx, *w_ih, *w_hh, (b_ih ? *b_ih : torch::Tensor()), (b_hh ? *b_hh : torch::Tensor()));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_roipooling2d_backward(tensor input, tensor rois, int64_t pooledHeight, int64_t pooledWidth, double spatialScale, tensor gradOutput, tensor argmaxes) {
  PROTECT(
    auto outputs__ = torch::RoiPooling2d_backward(*input, *rois, pooledHeight, pooledWidth, spatialScale, *gradOutput, *argmaxes);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_roll(tensor self, int64_t *shifts_data, int shifts_len, int64_t *dims_data, int dims_len) {
  PROTECT(
    auto outputs__ = torch::roll(*self, torch::IntList(shifts_data, shifts_len), torch::IntList(dims_data, dims_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rot90(tensor self, int64_t k, int64_t *dims_data, int dims_len) {
  PROTECT(
    auto outputs__ = torch::rot90(*self, k, torch::IntList(dims_data, dims_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_round(tensor self) {
  PROTECT(
    auto outputs__ = torch::round(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_round_(tensor self) {
  PROTECT(
    auto outputs__ = torch::round_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_round_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::round_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rrelu(tensor self, int training) {
  PROTECT(
    auto outputs__ = torch::rrelu(*self, (bool)training);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rrelu_(tensor self, int training) {
  PROTECT(
    auto outputs__ = torch::rrelu_(*self, (bool)training);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rrelu_with_noise(tensor self, tensor noise, int training) {
  PROTECT(
    auto outputs__ = torch::rrelu_with_noise(*self, *noise, (bool)training);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rrelu_with_noise_(tensor self, tensor noise, int training) {
  PROTECT(
    auto outputs__ = torch::rrelu_with_noise_(*self, *noise, (bool)training);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rrelu_with_noise_out(tensor output, tensor self, tensor noise, int training) {
  PROTECT(
    auto outputs__ = torch::rrelu_with_noise_out(*output, *self, *noise, (bool)training);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rsqrt(tensor self) {
  PROTECT(
    auto outputs__ = torch::rsqrt(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rsqrt_(tensor self) {
  PROTECT(
    auto outputs__ = torch::rsqrt_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rsqrt_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::rsqrt_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rsub(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::rsub(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_rsub1(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::rsub(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_s_native_addmm(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::s_native_addmm(*self, *mat1, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_s_native_addmm_(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::s_native_addmm_(*self, *mat1, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_s_native_addmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::s_native_addmm_out(*result, *self, *mat1, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_scatter_(tensor self, int64_t dim, tensor index, tensor src) {
  PROTECT(
    auto outputs__ = self->scatter_(dim, *index, *src);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_scatter_1(tensor self, int64_t dim, tensor index, scalar value) {
  PROTECT(
    auto outputs__ = self->scatter_(dim, *index, *value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_scatter_add_(tensor self, int64_t dim, tensor index, tensor src) {
  PROTECT(
    auto outputs__ = self->scatter_add_(dim, *index, *src);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_select(tensor self, int64_t dim, int64_t index) {
  PROTECT(
    auto outputs__ = torch::select(*self, dim, index);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_selu(tensor self) {
  PROTECT(
    auto outputs__ = torch::selu(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_selu_(tensor self) {
  PROTECT(
    auto outputs__ = torch::selu_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_set_(tensor self) {
  PROTECT(
    auto outputs__ = self->set_();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_set_1(tensor self, tensor source) {
  PROTECT(
    auto outputs__ = self->set_(*source);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_set_requires_grad(tensor self, int r) {
  PROTECT(
    auto outputs__ = self->set_requires_grad((bool)r);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sigmoid(tensor self) {
  PROTECT(
    auto outputs__ = torch::sigmoid(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sigmoid_(tensor self) {
  PROTECT(
    auto outputs__ = torch::sigmoid_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sigmoid_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::sigmoid_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sign(tensor self) {
  PROTECT(
    auto outputs__ = torch::sign(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sign_(tensor self) {
  PROTECT(
    auto outputs__ = self->sign_();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sign_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::sign_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sin(tensor self) {
  PROTECT(
    auto outputs__ = torch::sin(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sin_(tensor self) {
  PROTECT(
    auto outputs__ = torch::sin_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sin_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::sin_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sinh(tensor self) {
  PROTECT(
    auto outputs__ = torch::sinh(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sinh_(tensor self) {
  PROTECT(
    auto outputs__ = torch::sinh_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sinh_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::sinh_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_slice(tensor self, int64_t dim, int64_t start, int64_t end, int64_t step) {
  PROTECT(
    auto outputs__ = torch::slice(*self, dim, start, end, step);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_slogdet(tensor self) {
  PROTECT(
    auto outputs__ = torch::slogdet(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_smm(tensor self, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::smm(*self, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_smooth_l1_loss(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::smooth_l1_loss(*self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_smooth_l1_loss_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::smooth_l1_loss_backward(*grad_output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_smooth_l1_loss_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::smooth_l1_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_smooth_l1_loss_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::smooth_l1_loss_out(*output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_soft_margin_loss(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::soft_margin_loss(*self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_soft_margin_loss_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::soft_margin_loss_backward(*grad_output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_soft_margin_loss_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::soft_margin_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_soft_margin_loss_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::soft_margin_loss_out(*output, *self, *target, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_softmax(tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::softmax(*self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_softmax1(tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::softmax(*self, dim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_softplus(tensor self) {
  PROTECT(
    auto outputs__ = torch::softplus(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_softplus_out(tensor output, tensor self) {
  PROTECT(
    auto outputs__ = torch::softplus_out(*output, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_softshrink(tensor self) {
  PROTECT(
    auto outputs__ = torch::softshrink(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_softshrink_out(tensor output, tensor self) {
  PROTECT(
    auto outputs__ = torch::softshrink_out(*output, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sort(tensor self, int64_t dim, int descending) {
  PROTECT(
    auto outputs__ = torch::sort(*self, dim, (bool)descending);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_sort_out(tensor values, tensor indices, tensor self, int64_t dim, int descending) {
  PROTECT(
    auto outputs__ = torch::sort_out(*values, *indices, *self, dim, (bool)descending);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_sparse_coo_tensor(int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::sparse_coo_tensor(torch::IntList(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sparse_coo_tensor1(tensor indices, tensor values, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::sparse_coo_tensor(*indices, *values, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sparse_coo_tensor2(tensor indices, tensor values, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::sparse_coo_tensor(*indices, *values, torch::IntList(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sparse_resize_(tensor self, int64_t *size_data, int size_len, int64_t sparse_dim, int64_t dense_dim) {
  PROTECT(
    auto outputs__ = self->sparse_resize_(torch::IntList(size_data, size_len), sparse_dim, dense_dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sparse_resize_and_clear_(tensor self, int64_t *size_data, int size_len, int64_t sparse_dim, int64_t dense_dim) {
  PROTECT(
    auto outputs__ = self->sparse_resize_and_clear_(torch::IntList(size_data, size_len), sparse_dim, dense_dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_split(tensor self, int64_t split_size, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::split(*self, split_size, dim);
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
}

tensor *atg_split_with_sizes(tensor self, int64_t *split_sizes_data, int split_sizes_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::split_with_sizes(*self, torch::IntList(split_sizes_data, split_sizes_len), dim);
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
}

tensor *atg_sqrt(tensor self) {
  PROTECT(
    auto outputs__ = torch::sqrt(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sqrt_(tensor self) {
  PROTECT(
    auto outputs__ = torch::sqrt_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sqrt_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::sqrt_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_squeeze(tensor self) {
  PROTECT(
    auto outputs__ = torch::squeeze(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_squeeze1(tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::squeeze(*self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_squeeze_(tensor self) {
  PROTECT(
    auto outputs__ = self->squeeze_();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_squeeze_1(tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = self->squeeze_(dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sspaddmm(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::sspaddmm(*self, *mat1, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sspaddmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::sspaddmm_out(*result, *self, *mat1, *mat2);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_stack(tensor *tensors_data, int tensors_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::stack(of_carray_tensor(tensors_data, tensors_len), dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_stack_out(tensor result, tensor *tensors_data, int tensors_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::stack_out(*result, of_carray_tensor(tensors_data, tensors_len), dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_std(tensor self, int unbiased) {
  PROTECT(
    auto outputs__ = torch::std(*self, (bool)unbiased);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_std1(tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    auto outputs__ = torch::std(*self, dim, (bool)unbiased, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_std_out(tensor result, tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    auto outputs__ = torch::std_out(*result, *self, dim, (bool)unbiased, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_stft(tensor self, int64_t n_fft, int64_t hop_length, int64_t win_length, tensor window, int normalized, int onesided) {
  PROTECT(
    auto outputs__ = torch::stft(*self, n_fft, hop_length, win_length, (window ? *window : torch::Tensor()), (bool)normalized, (bool)onesided);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sub(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::sub(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sub1(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::sub(*self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sub_(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->sub_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sub_1(tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->sub_(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sub_out(tensor result, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::sub_out(*result, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sum(tensor self) {
  PROTECT(
    auto outputs__ = torch::sum(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sum1(tensor self, int dtype) {
  PROTECT(
    auto outputs__ = torch::sum(*self, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sum2(tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::sum(*self, torch::IntList(dim_data, dim_len), (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sum3(tensor self, int64_t *dim_data, int dim_len, int dtype) {
  PROTECT(
    auto outputs__ = torch::sum(*self, torch::IntList(dim_data, dim_len), at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sum4(tensor self, int64_t *dim_data, int dim_len, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::sum(*self, torch::IntList(dim_data, dim_len), (bool)keepdim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sum_out(tensor result, tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::sum_out(*result, *self, torch::IntList(dim_data, dim_len), (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sum_out1(tensor result, tensor self, int64_t *dim_data, int dim_len, int dtype) {
  PROTECT(
    auto outputs__ = torch::sum_out(*result, *self, torch::IntList(dim_data, dim_len), at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_sum_out2(tensor result, tensor self, int64_t *dim_data, int dim_len, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::sum_out(*result, *self, torch::IntList(dim_data, dim_len), (bool)keepdim, at::ScalarType(dtype));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_svd(tensor self, int some, int compute_uv) {
  PROTECT(
    auto outputs__ = torch::svd(*self, (bool)some, (bool)compute_uv);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_svd_out(tensor U, tensor S, tensor V, tensor self, int some, int compute_uv) {
  PROTECT(
    auto outputs__ = torch::svd_out(*U, *S, *V, *self, (bool)some, (bool)compute_uv);
    torch::Tensor **out__ = (torch::Tensor**)malloc(3*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    return out__;
  )
}

tensor *atg_symeig(tensor self, int eigenvectors, int upper) {
  PROTECT(
    auto outputs__ = torch::symeig(*self, (bool)eigenvectors, (bool)upper);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_symeig_out(tensor e, tensor V, tensor self, int eigenvectors, int upper) {
  PROTECT(
    auto outputs__ = torch::symeig_out(*e, *V, *self, (bool)eigenvectors, (bool)upper);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_t(tensor self) {
  PROTECT(
    auto outputs__ = torch::t(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_t_(tensor self) {
  PROTECT(
    auto outputs__ = self->t_();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_take(tensor self, tensor index) {
  PROTECT(
    auto outputs__ = torch::take(*self, *index);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_take_out(tensor result, tensor self, tensor index) {
  PROTECT(
    auto outputs__ = torch::take_out(*result, *self, *index);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_tan(tensor self) {
  PROTECT(
    auto outputs__ = torch::tan(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_tan_(tensor self) {
  PROTECT(
    auto outputs__ = torch::tan_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_tan_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::tan_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_tanh(tensor self) {
  PROTECT(
    auto outputs__ = torch::tanh(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_tanh_(tensor self) {
  PROTECT(
    auto outputs__ = torch::tanh_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_tanh_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::tanh_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_tensordot(tensor self, tensor other, int64_t *dims_self_data, int dims_self_len, int64_t *dims_other_data, int dims_other_len) {
  PROTECT(
    auto outputs__ = torch::tensordot(*self, *other, torch::IntList(dims_self_data, dims_self_len), torch::IntList(dims_other_data, dims_other_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_threshold(tensor self, scalar threshold, scalar value) {
  PROTECT(
    auto outputs__ = torch::threshold(*self, *threshold, *value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_threshold_(tensor self, scalar threshold, scalar value) {
  PROTECT(
    auto outputs__ = torch::threshold_(*self, *threshold, *value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_threshold_backward(tensor grad_output, tensor self, scalar threshold) {
  PROTECT(
    auto outputs__ = torch::threshold_backward(*grad_output, *self, *threshold);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_threshold_out(tensor result, tensor self, scalar threshold, scalar value) {
  PROTECT(
    auto outputs__ = torch::threshold_out(*result, *self, *threshold, *value);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_to(tensor self, int device) {
  PROTECT(
    auto outputs__ = self->to(device_of_int(device));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_to1(tensor self, int options_kind, int options_device, int non_blocking, int copy) {
  PROTECT(
    auto outputs__ = self->to(at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (bool)non_blocking, (bool)copy);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_to2(tensor self, int dtype, int non_blocking, int copy) {
  PROTECT(
    auto outputs__ = self->to(at::ScalarType(dtype), (bool)non_blocking, (bool)copy);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_to3(tensor self, tensor other, int non_blocking, int copy) {
  PROTECT(
    auto outputs__ = self->to(*other, (bool)non_blocking, (bool)copy);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_to4(tensor self, int device, int dtype, int non_blocking, int copy) {
  PROTECT(
    auto outputs__ = self->to(device_of_int(device), at::ScalarType(dtype), (bool)non_blocking, (bool)copy);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_to_dense(tensor self) {
  PROTECT(
    auto outputs__ = self->to_dense();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_to_sparse(tensor self) {
  PROTECT(
    auto outputs__ = self->to_sparse();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_to_sparse1(tensor self, int64_t sparse_dim) {
  PROTECT(
    auto outputs__ = self->to_sparse(sparse_dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_topk(tensor self, int64_t k, int64_t dim, int largest, int sorted) {
  PROTECT(
    auto outputs__ = torch::topk(*self, k, dim, (bool)largest, (bool)sorted);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_topk_out(tensor values, tensor indices, tensor self, int64_t k, int64_t dim, int largest, int sorted) {
  PROTECT(
    auto outputs__ = torch::topk_out(*values, *indices, *self, k, dim, (bool)largest, (bool)sorted);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_totype(tensor self, int scalar_type) {
  PROTECT(
    auto outputs__ = self->toType(at::ScalarType(scalar_type));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_trace(tensor self) {
  PROTECT(
    auto outputs__ = torch::trace(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_transpose(tensor self, int64_t dim0, int64_t dim1) {
  PROTECT(
    auto outputs__ = torch::transpose(*self, dim0, dim1);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_transpose_(tensor self, int64_t dim0, int64_t dim1) {
  PROTECT(
    auto outputs__ = self->transpose_(dim0, dim1);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_tril(tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::tril(*self, diagonal);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_tril_(tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = self->tril_(diagonal);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_tril_out(tensor result, tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::tril_out(*result, *self, diagonal);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_triplet_margin_loss(tensor anchor, tensor positive, tensor negative, double margin, double p, double eps, int swap, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::triplet_margin_loss(*anchor, *positive, *negative, margin, p, eps, (bool)swap, reduction);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_triu(tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::triu(*self, diagonal);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_triu_(tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = self->triu_(diagonal);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_triu_out(tensor result, tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::triu_out(*result, *self, diagonal);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_trtrs(tensor self, tensor A, int upper, int transpose, int unitriangular) {
  PROTECT(
    auto outputs__ = torch::trtrs(*self, *A, (bool)upper, (bool)transpose, (bool)unitriangular);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_trtrs_out(tensor X, tensor M, tensor self, tensor A, int upper, int transpose, int unitriangular) {
  PROTECT(
    auto outputs__ = torch::trtrs_out(*X, *M, *self, *A, (bool)upper, (bool)transpose, (bool)unitriangular);
    torch::Tensor **out__ = (torch::Tensor**)malloc(2*sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    return out__;
  )
}

tensor *atg_trunc(tensor self) {
  PROTECT(
    auto outputs__ = torch::trunc(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_trunc_(tensor self) {
  PROTECT(
    auto outputs__ = torch::trunc_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_trunc_out(tensor result, tensor self) {
  PROTECT(
    auto outputs__ = torch::trunc_out(*result, *self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_type_as(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->type_as(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_unbind(tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::unbind(*self, dim);
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
}

tensor *atg_unfold(tensor self, int64_t dimension, int64_t size, int64_t step) {
  PROTECT(
    auto outputs__ = self->unfold(dimension, size, step);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_uniform_(tensor self, double from, double to) {
  PROTECT(
    auto outputs__ = self->uniform_(from, to);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_unsqueeze(tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::unsqueeze(*self, dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_unsqueeze_(tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = self->unsqueeze_(dim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_bilinear2d(tensor self, int64_t *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_bilinear2d(*self, torch::IntList(output_size_data, output_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_bilinear2d_backward(tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_bilinear2d_backward(*grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_bilinear2d_backward_out(tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_bilinear2d_backward_out(*grad_input, *grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_bilinear2d_out(tensor output, tensor self, int64_t *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_bilinear2d_out(*output, *self, torch::IntList(output_size_data, output_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_linear1d(tensor self, int64_t *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_linear1d(*self, torch::IntList(output_size_data, output_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_linear1d_backward(tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_linear1d_backward(*grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_linear1d_backward_out(tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_linear1d_backward_out(*grad_input, *grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_linear1d_out(tensor output, tensor self, int64_t *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_linear1d_out(*output, *self, torch::IntList(output_size_data, output_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest1d(tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest1d(*self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest1d_backward(tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest1d_backward(*grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest1d_backward_out(tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest1d_backward_out(*grad_input, *grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest1d_out(tensor output, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest1d_out(*output, *self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest2d(tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest2d(*self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest2d_backward(tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest2d_backward(*grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest2d_backward_out(tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest2d_backward_out(*grad_input, *grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest2d_out(tensor output, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest2d_out(*output, *self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest3d(tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest3d(*self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest3d_backward(tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest3d_backward(*grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest3d_backward_out(tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest3d_backward_out(*grad_input, *grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_nearest3d_out(tensor output, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest3d_out(*output, *self, torch::IntList(output_size_data, output_size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_trilinear3d(tensor self, int64_t *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_trilinear3d(*self, torch::IntList(output_size_data, output_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_trilinear3d_backward(tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_trilinear3d_backward(*grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_trilinear3d_backward_out(tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_trilinear3d_backward_out(*grad_input, *grad_output, torch::IntList(output_size_data, output_size_len), torch::IntList(input_size_data, input_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_upsample_trilinear3d_out(tensor output, tensor self, int64_t *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::upsample_trilinear3d_out(*output, *self, torch::IntList(output_size_data, output_size_len), (bool)align_corners);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_values(tensor self) {
  PROTECT(
    auto outputs__ = self->values();
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_var(tensor self, int unbiased) {
  PROTECT(
    auto outputs__ = torch::var(*self, (bool)unbiased);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_var1(tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    auto outputs__ = torch::var(*self, dim, (bool)unbiased, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_var_out(tensor result, tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    auto outputs__ = torch::var_out(*result, *self, dim, (bool)unbiased, (bool)keepdim);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_view(tensor self, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = self->view(torch::IntList(size_data, size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_view_as(tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->view_as(*other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_where(tensor condition, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::where(*condition, *self, *other);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_zero_(tensor self) {
  PROTECT(
    auto outputs__ = torch::zero_(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_zeros(int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::zeros(torch::IntList(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_zeros_like(tensor self) {
  PROTECT(
    auto outputs__ = torch::zeros_like(*self);
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_zeros_like1(tensor self, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::zeros_like(*self, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

tensor *atg_zeros_out(tensor result, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::zeros_out(*result, torch::IntList(size_data, size_len));
    torch::Tensor **out__ = (torch::Tensor**)malloc(sizeof(torch::Tensor*));
    out__[0] = new torch::Tensor(outputs__);
    return out__;
  )
}

