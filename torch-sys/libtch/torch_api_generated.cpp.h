// THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND!

void atg___and__(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::__and__(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___and__1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::__and__(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___iand__(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->__iand__(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___iand__1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->__iand__(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___ilshift__(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->__ilshift__(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___ilshift__1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->__ilshift__(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___ior__(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->__ior__(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___ior__1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->__ior__(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___irshift__(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->__irshift__(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___irshift__1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->__irshift__(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___ixor__(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->__ixor__(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___ixor__1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->__ixor__(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___lshift__(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::__lshift__(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___lshift__1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::__lshift__(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___or__(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::__or__(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___or__1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::__or__(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___rshift__(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::__rshift__(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___rshift__1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::__rshift__(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___xor__(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::__xor__(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg___xor__1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::__xor__(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__adaptive_avg_pool2d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::_adaptive_avg_pool2d(*self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__adaptive_avg_pool2d_backward(tensor *out__, tensor grad_output, tensor self) {
  PROTECT(
    auto outputs__ = torch::_adaptive_avg_pool2d_backward(*grad_output, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__addr(tensor *out__, tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    auto outputs__ = torch::_addr(*self, *vec1, *vec2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__addr_(tensor *out__, tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    auto outputs__ = torch::_addr_(*self, *vec1, *vec2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__addr_out(tensor *out__, tensor out, tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    auto outputs__ = torch::_addr_out(*out, *self, *vec1, *vec2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__amp_update_scale(tensor *out__, tensor growth_tracker, tensor current_scale, tensor found_inf, double scale_growth_factor, double scale_backoff_factor, int64_t growth_interval) {
  PROTECT(
    auto outputs__ = torch::_amp_update_scale(*growth_tracker, *current_scale, *found_inf, scale_growth_factor, scale_backoff_factor, growth_interval);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__baddbmm_mkl_(tensor *out__, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = torch::_baddbmm_mkl_(*self, *batch1, *batch2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cast_byte(tensor *out__, tensor self, int non_blocking) {
  PROTECT(
    auto outputs__ = torch::_cast_Byte(*self, (bool)non_blocking);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cast_char(tensor *out__, tensor self, int non_blocking) {
  PROTECT(
    auto outputs__ = torch::_cast_Char(*self, (bool)non_blocking);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cast_double(tensor *out__, tensor self, int non_blocking) {
  PROTECT(
    auto outputs__ = torch::_cast_Double(*self, (bool)non_blocking);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cast_float(tensor *out__, tensor self, int non_blocking) {
  PROTECT(
    auto outputs__ = torch::_cast_Float(*self, (bool)non_blocking);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cast_half(tensor *out__, tensor self, int non_blocking) {
  PROTECT(
    auto outputs__ = torch::_cast_Half(*self, (bool)non_blocking);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cast_int(tensor *out__, tensor self, int non_blocking) {
  PROTECT(
    auto outputs__ = torch::_cast_Int(*self, (bool)non_blocking);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cast_long(tensor *out__, tensor self, int non_blocking) {
  PROTECT(
    auto outputs__ = torch::_cast_Long(*self, (bool)non_blocking);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cast_short(tensor *out__, tensor self, int non_blocking) {
  PROTECT(
    auto outputs__ = torch::_cast_Short(*self, (bool)non_blocking);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cat(tensor *out__, tensor *tensors_data, int tensors_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::_cat(of_carray_tensor(tensors_data, tensors_len), dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cat_out(tensor *out__, tensor out, tensor *tensors_data, int tensors_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::_cat_out(*out, of_carray_tensor(tensors_data, tensors_len), dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cdist_backward(tensor *out__, tensor grad, tensor x1, tensor x2, double p, tensor cdist) {
  PROTECT(
    auto outputs__ = torch::_cdist_backward(*grad, *x1, *x2, p, *cdist);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cholesky_helper(tensor *out__, tensor self, int upper) {
  PROTECT(
    auto outputs__ = torch::_cholesky_helper(*self, (bool)upper);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cholesky_solve_helper(tensor *out__, tensor self, tensor A, int upper) {
  PROTECT(
    auto outputs__ = torch::_cholesky_solve_helper(*self, *A, (bool)upper);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__coalesced_(tensor *out__, tensor self, int coalesced) {
  PROTECT(
    auto outputs__ = self->_coalesced_((bool)coalesced);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__convolution(tensor *out__, tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int transposed, int64_t *output_padding_data, int output_padding_len, int64_t groups, int benchmark, int deterministic, int cudnn_enabled) {
  PROTECT(
    auto outputs__ = torch::_convolution(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)transposed, torch::IntArrayRef(output_padding_data, output_padding_len), groups, (bool)benchmark, (bool)deterministic, (bool)cudnn_enabled);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__convolution_nogroup(tensor *out__, tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int transposed, int64_t *output_padding_data, int output_padding_len) {
  PROTECT(
    auto outputs__ = torch::_convolution_nogroup(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)transposed, torch::IntArrayRef(output_padding_data, output_padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__copy_from(tensor *out__, tensor self, tensor dst, int non_blocking) {
  PROTECT(
    auto outputs__ = torch::_copy_from(*self, *dst, (bool)non_blocking);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__ctc_loss(tensor *out__, tensor log_probs, tensor targets, int64_t *input_lengths_data, int input_lengths_len, int64_t *target_lengths_data, int target_lengths_len, int64_t blank, int zero_infinity) {
  PROTECT(
    auto outputs__ = torch::_ctc_loss(*log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), blank, (bool)zero_infinity);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__ctc_loss_backward(tensor *out__, tensor grad, tensor log_probs, tensor targets, int64_t *input_lengths_data, int input_lengths_len, int64_t *target_lengths_data, int target_lengths_len, tensor neg_log_likelihood, tensor log_alpha, int64_t blank, int zero_infinity) {
  PROTECT(
    auto outputs__ = torch::_ctc_loss_backward(*grad, *log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), *neg_log_likelihood, *log_alpha, blank, (bool)zero_infinity);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cudnn_ctc_loss(tensor *out__, tensor log_probs, tensor targets, int64_t *input_lengths_data, int input_lengths_len, int64_t *target_lengths_data, int target_lengths_len, int64_t blank, int deterministic, int zero_infinity) {
  PROTECT(
    auto outputs__ = torch::_cudnn_ctc_loss(*log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), blank, (bool)deterministic, (bool)zero_infinity);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__cudnn_init_dropout_state(tensor *out__, double dropout, int train, int64_t dropout_seed, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::_cudnn_init_dropout_state(dropout, (bool)train, dropout_seed, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cudnn_rnn(tensor *out__, tensor input, tensor *weight_data, int weight_len, int64_t weight_stride0, tensor weight_buf, tensor hx, tensor cx, int64_t mode, int64_t hidden_size, int64_t num_layers, int batch_first, double dropout, int train, int bidirectional, int64_t *batch_sizes_data, int batch_sizes_len, tensor dropout_state) {
  PROTECT(
    auto outputs__ = torch::_cudnn_rnn(*input, of_carray_tensor(weight_data, weight_len), weight_stride0, (weight_buf ? *weight_buf : torch::Tensor()), *hx, (cx ? *cx : torch::Tensor()), mode, hidden_size, num_layers, (bool)batch_first, dropout, (bool)train, (bool)bidirectional, torch::IntArrayRef(batch_sizes_data, batch_sizes_len), (dropout_state ? *dropout_state : torch::Tensor()));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    out__[3] = new torch::Tensor(std::get<3>(outputs__));
    out__[4] = new torch::Tensor(std::get<4>(outputs__));
  )
}

void atg__cudnn_rnn_flatten_weight(tensor *out__, tensor *weight_arr_data, int weight_arr_len, int64_t weight_stride0, int64_t input_size, int64_t mode, int64_t hidden_size, int64_t num_layers, int batch_first, int bidirectional) {
  PROTECT(
    auto outputs__ = torch::_cudnn_rnn_flatten_weight(of_carray_tensor(weight_arr_data, weight_arr_len), weight_stride0, input_size, mode, hidden_size, num_layers, (bool)batch_first, (bool)bidirectional);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cumprod(tensor *out__, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::_cumprod(*self, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cumprod_out(tensor *out__, tensor out, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::_cumprod_out(*out, *self, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cumsum(tensor *out__, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::_cumsum(*self, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__cumsum_out(tensor *out__, tensor out, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::_cumsum_out(*out, *self, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__dim_arange(tensor *out__, tensor like, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::_dim_arange(*like, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__dirichlet_grad(tensor *out__, tensor x, tensor alpha, tensor total) {
  PROTECT(
    auto outputs__ = torch::_dirichlet_grad(*x, *alpha, *total);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__embedding_bag(tensor *out__, tensor weight, tensor indices, tensor offsets, int scale_grad_by_freq, int64_t mode, int sparse, tensor per_sample_weights, int include_last_offset) {
  PROTECT(
    auto outputs__ = torch::_embedding_bag(*weight, *indices, *offsets, (bool)scale_grad_by_freq, mode, (bool)sparse, (per_sample_weights ? *per_sample_weights : torch::Tensor()), (bool)include_last_offset);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    out__[3] = new torch::Tensor(std::get<3>(outputs__));
  )
}

void atg__embedding_bag_backward(tensor *out__, tensor grad, tensor indices, tensor offsets, tensor offset2bag, tensor bag_size, tensor maximum_indices, int64_t num_weights, int scale_grad_by_freq, int64_t mode, int sparse, tensor per_sample_weights) {
  PROTECT(
    auto outputs__ = torch::_embedding_bag_backward(*grad, *indices, *offsets, *offset2bag, *bag_size, *maximum_indices, num_weights, (bool)scale_grad_by_freq, mode, (bool)sparse, (per_sample_weights ? *per_sample_weights : torch::Tensor()));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__embedding_bag_dense_backward(tensor *out__, tensor grad, tensor indices, tensor offsets, tensor offset2bag, tensor bag_size, tensor maximum_indices, int64_t num_weights, int scale_grad_by_freq, int64_t mode, tensor per_sample_weights) {
  PROTECT(
    auto outputs__ = torch::_embedding_bag_dense_backward(*grad, *indices, *offsets, *offset2bag, *bag_size, *maximum_indices, num_weights, (bool)scale_grad_by_freq, mode, (per_sample_weights ? *per_sample_weights : torch::Tensor()));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__embedding_bag_per_sample_weights_backward(tensor *out__, tensor grad, tensor weight, tensor indices, tensor offsets, tensor offset2bag, int64_t mode) {
  PROTECT(
    auto outputs__ = torch::_embedding_bag_per_sample_weights_backward(*grad, *weight, *indices, *offsets, *offset2bag, mode);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__embedding_bag_sparse_backward(tensor *out__, tensor grad, tensor indices, tensor offsets, tensor offset2bag, tensor bag_size, int64_t num_weights, int scale_grad_by_freq, int64_t mode, tensor per_sample_weights) {
  PROTECT(
    auto outputs__ = torch::_embedding_bag_sparse_backward(*grad, *indices, *offsets, *offset2bag, *bag_size, num_weights, (bool)scale_grad_by_freq, mode, (per_sample_weights ? *per_sample_weights : torch::Tensor()));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__empty_affine_quantized(tensor *out__, int64_t *size_data, int size_len, int options_kind, int options_device, double scale, int64_t zero_point) {
  PROTECT(
    auto outputs__ = torch::_empty_affine_quantized(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), scale, zero_point);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__empty_per_channel_affine_quantized(tensor *out__, int64_t *size_data, int size_len, tensor scales, tensor zero_points, int64_t axis, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::_empty_per_channel_affine_quantized(torch::IntArrayRef(size_data, size_len), *scales, *zero_points, axis, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__fft_with_size(tensor *out__, tensor self, int64_t signal_ndim, int complex_input, int complex_output, int inverse, int64_t *checked_signal_sizes_data, int checked_signal_sizes_len, int normalized, int onesided, int64_t *output_sizes_data, int output_sizes_len) {
  PROTECT(
    auto outputs__ = torch::_fft_with_size(*self, signal_ndim, (bool)complex_input, (bool)complex_output, (bool)inverse, torch::IntArrayRef(checked_signal_sizes_data, checked_signal_sizes_len), (bool)normalized, (bool)onesided, torch::IntArrayRef(output_sizes_data, output_sizes_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__fused_dropout(tensor *out__, tensor self, double p) {
  PROTECT(
    auto outputs__ = torch::_fused_dropout(*self, p);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__gather_sparse_backward(tensor *out__, tensor self, int64_t dim, tensor index, tensor grad) {
  PROTECT(
    auto outputs__ = torch::_gather_sparse_backward(*self, dim, *index, *grad);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__index_copy_(tensor *out__, tensor self, int64_t dim, tensor index, tensor source) {
  PROTECT(
    auto outputs__ = torch::_index_copy_(*self, dim, *index, *source);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__index_put_impl_(tensor *out__, tensor self, tensor *indices_data, int indices_len, tensor values, int accumulate, int unsafe) {
  PROTECT(
    auto outputs__ = torch::_index_put_impl_(*self, of_carray_tensor(indices_data, indices_len), *values, (bool)accumulate, (bool)unsafe);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__indices(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->_indices();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__inverse_helper(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::_inverse_helper(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__log_softmax(tensor *out__, tensor self, int64_t dim, int half_to_float) {
  PROTECT(
    auto outputs__ = torch::_log_softmax(*self, dim, (bool)half_to_float);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__log_softmax_backward_data(tensor *out__, tensor grad_output, tensor output, int64_t dim, tensor self) {
  PROTECT(
    auto outputs__ = torch::_log_softmax_backward_data(*grad_output, *output, dim, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__lu_solve_helper(tensor *out__, tensor self, tensor LU_data, tensor LU_pivots) {
  PROTECT(
    auto outputs__ = torch::_lu_solve_helper(*self, *LU_data, *LU_pivots);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__lu_with_info(tensor *out__, tensor self, int pivot, int check_errors) {
  PROTECT(
    auto outputs__ = torch::_lu_with_info(*self, (bool)pivot, (bool)check_errors);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg__make_per_channel_quantized_tensor(tensor *out__, tensor self, tensor scale, tensor zero_point, int64_t axis) {
  PROTECT(
    auto outputs__ = torch::_make_per_channel_quantized_tensor(*self, *scale, *zero_point, axis);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__make_per_tensor_quantized_tensor(tensor *out__, tensor self, double scale, int64_t zero_point) {
  PROTECT(
    auto outputs__ = torch::_make_per_tensor_quantized_tensor(*self, scale, zero_point);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__masked_scale(tensor *out__, tensor self, tensor mask, double scale) {
  PROTECT(
    auto outputs__ = torch::_masked_scale(*self, *mask, scale);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__max(tensor *out__, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::_max(*self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__max_out(tensor *out__, tensor max, tensor max_indices, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::_max_out(*max, *max_indices, *self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__min(tensor *out__, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::_min(*self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__min_out(tensor *out__, tensor min, tensor min_indices, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::_min_out(*min, *min_indices, *self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__mkldnn_reshape(tensor *out__, tensor self, int64_t *shape_data, int shape_len) {
  PROTECT(
    auto outputs__ = torch::_mkldnn_reshape(*self, torch::IntArrayRef(shape_data, shape_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__mkldnn_transpose(tensor *out__, tensor self, int64_t dim0, int64_t dim1) {
  PROTECT(
    auto outputs__ = torch::_mkldnn_transpose(*self, dim0, dim1);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__mkldnn_transpose_(tensor *out__, tensor self, int64_t dim0, int64_t dim1) {
  PROTECT(
    auto outputs__ = torch::_mkldnn_transpose_(*self, dim0, dim1);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__mode(tensor *out__, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::_mode(*self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__mode_out(tensor *out__, tensor values, tensor indices, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::_mode_out(*values, *indices, *self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__multinomial_alias_draw(tensor *out__, tensor J, tensor q, int64_t num_samples) {
  PROTECT(
    auto outputs__ = torch::_multinomial_alias_draw(*J, *q, num_samples);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__multinomial_alias_setup(tensor *out__, tensor probs) {
  PROTECT(
    auto outputs__ = torch::_multinomial_alias_setup(*probs);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__nnpack_spatial_convolution(tensor *out__, tensor input, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len) {
  PROTECT(
    auto outputs__ = torch::_nnpack_spatial_convolution(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__nnpack_spatial_convolution_backward_input(tensor *out__, tensor input, tensor grad_output, tensor weight, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::_nnpack_spatial_convolution_backward_input(*input, *grad_output, *weight, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__nnpack_spatial_convolution_backward_weight(tensor *out__, tensor input, int64_t *weightsize_data, int weightsize_len, tensor grad_output, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::_nnpack_spatial_convolution_backward_weight(*input, torch::IntArrayRef(weightsize_data, weightsize_len), *grad_output, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__pack_padded_sequence(tensor *out__, tensor input, tensor lengths, int batch_first) {
  PROTECT(
    auto outputs__ = torch::_pack_padded_sequence(*input, *lengths, (bool)batch_first);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__pack_padded_sequence_backward(tensor *out__, tensor grad, int64_t *input_size_data, int input_size_len, tensor batch_sizes, int batch_first) {
  PROTECT(
    auto outputs__ = torch::_pack_padded_sequence_backward(*grad, torch::IntArrayRef(input_size_data, input_size_len), *batch_sizes, (bool)batch_first);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__pad_packed_sequence(tensor *out__, tensor data, tensor batch_sizes, int batch_first, scalar padding_value, int64_t total_length) {
  PROTECT(
    auto outputs__ = torch::_pad_packed_sequence(*data, *batch_sizes, (bool)batch_first, *padding_value, total_length);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__pdist_backward(tensor *out__, tensor grad, tensor self, double p, tensor pdist) {
  PROTECT(
    auto outputs__ = torch::_pdist_backward(*grad, *self, p, *pdist);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__qr_helper(tensor *out__, tensor self, int some) {
  PROTECT(
    auto outputs__ = torch::_qr_helper(*self, (bool)some);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__reshape_from_tensor(tensor *out__, tensor self, tensor shape) {
  PROTECT(
    auto outputs__ = torch::_reshape_from_tensor(*self, *shape);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__s_where(tensor *out__, tensor condition, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::_s_where(*condition, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sample_dirichlet(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::_sample_dirichlet(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__shape_as_tensor(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::_shape_as_tensor(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sobol_engine_draw(tensor *out__, tensor quasi, int64_t n, tensor sobolstate, int64_t dimension, int64_t num_generated, int dtype) {
  PROTECT(
    auto outputs__ = torch::_sobol_engine_draw(*quasi, n, *sobolstate, dimension, num_generated, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__sobol_engine_ff_(tensor *out__, tensor self, int64_t n, tensor sobolstate, int64_t dimension, int64_t num_generated) {
  PROTECT(
    auto outputs__ = torch::_sobol_engine_ff_(*self, n, *sobolstate, dimension, num_generated);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sobol_engine_initialize_state_(tensor *out__, tensor self, int64_t dimension) {
  PROTECT(
    auto outputs__ = torch::_sobol_engine_initialize_state_(*self, dimension);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sobol_engine_scramble_(tensor *out__, tensor self, tensor ltm, int64_t dimension) {
  PROTECT(
    auto outputs__ = torch::_sobol_engine_scramble_(*self, *ltm, dimension);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__softmax(tensor *out__, tensor self, int64_t dim, int half_to_float) {
  PROTECT(
    auto outputs__ = torch::_softmax(*self, dim, (bool)half_to_float);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__softmax_backward_data(tensor *out__, tensor grad_output, tensor output, int64_t dim, tensor self) {
  PROTECT(
    auto outputs__ = torch::_softmax_backward_data(*grad_output, *output, dim, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__solve_helper(tensor *out__, tensor self, tensor A) {
  PROTECT(
    auto outputs__ = torch::_solve_helper(*self, *A);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__sparse_addmm(tensor *out__, tensor self, tensor sparse, tensor dense) {
  PROTECT(
    auto outputs__ = torch::_sparse_addmm(*self, *sparse, *dense);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sparse_coo_tensor_unsafe(tensor *out__, tensor indices, tensor values, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::_sparse_coo_tensor_unsafe(*indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sparse_coo_tensor_with_dims(tensor *out__, int64_t sparse_dim, int64_t dense_dim, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::_sparse_coo_tensor_with_dims(sparse_dim, dense_dim, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sparse_coo_tensor_with_dims_and_tensors(tensor *out__, int64_t sparse_dim, int64_t dense_dim, int64_t *size_data, int size_len, tensor indices, tensor values, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::_sparse_coo_tensor_with_dims_and_tensors(sparse_dim, dense_dim, torch::IntArrayRef(size_data, size_len), *indices, *values, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sparse_mm(tensor *out__, tensor sparse, tensor dense) {
  PROTECT(
    auto outputs__ = torch::_sparse_mm(*sparse, *dense);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sparse_sum(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::_sparse_sum(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sparse_sum1(tensor *out__, tensor self, int dtype) {
  PROTECT(
    auto outputs__ = torch::_sparse_sum(*self, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sparse_sum2(tensor *out__, tensor self, int64_t *dim_data, int dim_len) {
  PROTECT(
    auto outputs__ = torch::_sparse_sum(*self, torch::IntArrayRef(dim_data, dim_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sparse_sum3(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int dtype) {
  PROTECT(
    auto outputs__ = torch::_sparse_sum(*self, torch::IntArrayRef(dim_data, dim_len), at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__sparse_sum_backward(tensor *out__, tensor grad, tensor self, int64_t *dim_data, int dim_len) {
  PROTECT(
    auto outputs__ = torch::_sparse_sum_backward(*grad, *self, torch::IntArrayRef(dim_data, dim_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__standard_gamma(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::_standard_gamma(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__standard_gamma_grad(tensor *out__, tensor self, tensor output) {
  PROTECT(
    auto outputs__ = torch::_standard_gamma_grad(*self, *output);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__std(tensor *out__, tensor self, int unbiased) {
  PROTECT(
    auto outputs__ = torch::_std(*self, (bool)unbiased);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__svd_helper(tensor *out__, tensor self, int some, int compute_uv) {
  PROTECT(
    auto outputs__ = torch::_svd_helper(*self, (bool)some, (bool)compute_uv);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg__symeig_helper(tensor *out__, tensor self, int eigenvectors, int upper) {
  PROTECT(
    auto outputs__ = torch::_symeig_helper(*self, (bool)eigenvectors, (bool)upper);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__triangular_solve_helper(tensor *out__, tensor self, tensor A, int upper, int transpose, int unitriangular) {
  PROTECT(
    auto outputs__ = torch::_triangular_solve_helper(*self, *A, (bool)upper, (bool)transpose, (bool)unitriangular);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__trilinear(tensor *out__, tensor i1, tensor i2, tensor i3, int64_t *expand1_data, int expand1_len, int64_t *expand2_data, int expand2_len, int64_t *expand3_data, int expand3_len, int64_t *sumdim_data, int sumdim_len, int64_t unroll_dim) {
  PROTECT(
    auto outputs__ = torch::_trilinear(*i1, *i2, *i3, torch::IntArrayRef(expand1_data, expand1_len), torch::IntArrayRef(expand2_data, expand2_len), torch::IntArrayRef(expand3_data, expand3_len), torch::IntArrayRef(sumdim_data, sumdim_len), unroll_dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__unique(tensor *out__, tensor self, int sorted, int return_inverse) {
  PROTECT(
    auto outputs__ = torch::_unique(*self, (bool)sorted, (bool)return_inverse);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__unique2(tensor *out__, tensor self, int sorted, int return_inverse, int return_counts) {
  PROTECT(
    auto outputs__ = torch::_unique2(*self, (bool)sorted, (bool)return_inverse, (bool)return_counts);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg__unsafe_view(tensor *out__, tensor self, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::_unsafe_view(*self, torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__values(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->_values();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__var(tensor *out__, tensor self, int unbiased) {
  PROTECT(
    auto outputs__ = torch::_var(*self, (bool)unbiased);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__weight_norm(tensor *out__, tensor v, tensor g, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::_weight_norm(*v, *g, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg__weight_norm_cuda_interface(tensor *out__, tensor v, tensor g, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::_weight_norm_cuda_interface(*v, *g, dim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__weight_norm_cuda_interface_backward(tensor *out__, tensor grad_w, tensor saved_v, tensor saved_g, tensor saved_norms, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::_weight_norm_cuda_interface_backward(*grad_w, *saved_v, *saved_g, *saved_norms, dim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg__weight_norm_differentiable_backward(tensor *out__, tensor grad_w, tensor saved_v, tensor saved_g, tensor saved_norms, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::_weight_norm_differentiable_backward(*grad_w, *saved_v, *saved_g, *saved_norms, dim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_abs(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::abs(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_abs_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::abs_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_abs_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::abs_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_acos(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::acos(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_acos_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::acos_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_acos_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::acos_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_avg_pool1d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool1d(*self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_avg_pool2d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool2d(*self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_avg_pool2d_out(tensor *out__, tensor out, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool2d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_avg_pool3d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool3d(*self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_avg_pool3d_backward(tensor *out__, tensor grad_output, tensor self) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool3d_backward(*grad_output, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_avg_pool3d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool3d_backward_out(*grad_input, *grad_output, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_avg_pool3d_out(tensor *out__, tensor out, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_avg_pool3d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_max_pool1d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool1d(*self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_adaptive_max_pool2d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool2d(*self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_adaptive_max_pool2d_backward(tensor *out__, tensor grad_output, tensor self, tensor indices) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool2d_backward(*grad_output, *self, *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_max_pool2d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor indices) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool2d_backward_out(*grad_input, *grad_output, *self, *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_max_pool2d_out(tensor *out__, tensor out, tensor indices, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool2d_out(*out, *indices, *self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_adaptive_max_pool3d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool3d(*self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_adaptive_max_pool3d_backward(tensor *out__, tensor grad_output, tensor self, tensor indices) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool3d_backward(*grad_output, *self, *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_max_pool3d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor indices) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool3d_backward_out(*grad_input, *grad_output, *self, *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_adaptive_max_pool3d_out(tensor *out__, tensor out, tensor indices, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::adaptive_max_pool3d_out(*out, *indices, *self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_add(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::add(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_add1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::add(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_add_(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->add_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_add_1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->add_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_add_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::add_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addbmm(tensor *out__, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = torch::addbmm(*self, *batch1, *batch2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addbmm_(tensor *out__, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = self->addbmm_(*batch1, *batch2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addbmm_out(tensor *out__, tensor out, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = torch::addbmm_out(*out, *self, *batch1, *batch2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addcdiv(tensor *out__, tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = torch::addcdiv(*self, *tensor1, *tensor2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addcdiv_(tensor *out__, tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = self->addcdiv_(*tensor1, *tensor2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addcdiv_out(tensor *out__, tensor out, tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = torch::addcdiv_out(*out, *self, *tensor1, *tensor2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addcmul(tensor *out__, tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = torch::addcmul(*self, *tensor1, *tensor2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addcmul_(tensor *out__, tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = self->addcmul_(*tensor1, *tensor2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addcmul_out(tensor *out__, tensor out, tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    auto outputs__ = torch::addcmul_out(*out, *self, *tensor1, *tensor2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addmm(tensor *out__, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::addmm(*self, *mat1, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addmm_(tensor *out__, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = self->addmm_(*mat1, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addmm_out(tensor *out__, tensor out, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::addmm_out(*out, *self, *mat1, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addmv(tensor *out__, tensor self, tensor mat, tensor vec) {
  PROTECT(
    auto outputs__ = torch::addmv(*self, *mat, *vec);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addmv_(tensor *out__, tensor self, tensor mat, tensor vec) {
  PROTECT(
    auto outputs__ = torch::addmv_(*self, *mat, *vec);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addmv_out(tensor *out__, tensor out, tensor self, tensor mat, tensor vec) {
  PROTECT(
    auto outputs__ = torch::addmv_out(*out, *self, *mat, *vec);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addr(tensor *out__, tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    auto outputs__ = torch::addr(*self, *vec1, *vec2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addr_(tensor *out__, tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    auto outputs__ = self->addr_(*vec1, *vec2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_addr_out(tensor *out__, tensor out, tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    auto outputs__ = torch::addr_out(*out, *self, *vec1, *vec2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_affine_grid_generator(tensor *out__, tensor theta, int64_t *size_data, int size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::affine_grid_generator(*theta, torch::IntArrayRef(size_data, size_len), (bool)align_corners);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_affine_grid_generator_backward(tensor *out__, tensor grad, int64_t *size_data, int size_len, int align_corners) {
  PROTECT(
    auto outputs__ = torch::affine_grid_generator_backward(*grad, torch::IntArrayRef(size_data, size_len), (bool)align_corners);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_alias(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::alias(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_align_as(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->align_as(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

tensor *atg_align_tensors(tensor *tensors_data, int tensors_len) {
  PROTECT(
    auto outputs__ = torch::align_tensors(of_carray_tensor(tensors_data, tensors_len));
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
  return nullptr;
}

void atg_all(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::all(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_all1(tensor *out__, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::all(*self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_all_out(tensor *out__, tensor out, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::all_out(*out, *self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_alpha_dropout(tensor *out__, tensor input, double p, int train) {
  PROTECT(
    auto outputs__ = torch::alpha_dropout(*input, p, (bool)train);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_alpha_dropout_(tensor *out__, tensor self, double p, int train) {
  PROTECT(
    auto outputs__ = torch::alpha_dropout_(*self, p, (bool)train);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_angle(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::angle(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_angle_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::angle_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_any(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::any(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_any1(tensor *out__, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::any(*self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_any_out(tensor *out__, tensor out, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::any_out(*out, *self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_arange(tensor *out__, scalar end, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::arange(*end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_arange1(tensor *out__, scalar start, scalar end, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::arange(*start, *end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_arange2(tensor *out__, scalar start, scalar end, scalar step, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::arange(*start, *end, *step, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_arange_out(tensor *out__, tensor out, scalar end) {
  PROTECT(
    auto outputs__ = torch::arange_out(*out, *end);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_arange_out1(tensor *out__, tensor out, scalar start, scalar end) {
  PROTECT(
    auto outputs__ = torch::arange_out(*out, *start, *end);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_argmax(tensor *out__, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::argmax(*self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_argmin(tensor *out__, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::argmin(*self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_argsort(tensor *out__, tensor self, int64_t dim, int descending) {
  PROTECT(
    auto outputs__ = torch::argsort(*self, dim, (bool)descending);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_as_strided(tensor *out__, tensor self, int64_t *size_data, int size_len, int64_t *stride_data, int stride_len, int64_t storage_offset) {
  PROTECT(
    auto outputs__ = torch::as_strided(*self, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len), storage_offset);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_as_strided_(tensor *out__, tensor self, int64_t *size_data, int size_len, int64_t *stride_data, int stride_len, int64_t storage_offset) {
  PROTECT(
    auto outputs__ = torch::as_strided_(*self, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len), storage_offset);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_asin(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::asin(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_asin_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::asin_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_asin_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::asin_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_atan(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::atan(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_atan2(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::atan2(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_atan2_(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->atan2_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_atan2_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::atan2_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_atan_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::atan_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_atan_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::atan_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_avg_pool1d(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    auto outputs__ = torch::avg_pool1d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_avg_pool2d(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad, int64_t divisor_override) {
  PROTECT(
    auto outputs__ = torch::avg_pool2d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad, divisor_override);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_avg_pool2d_backward(tensor *out__, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad, int64_t divisor_override) {
  PROTECT(
    auto outputs__ = torch::avg_pool2d_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad, divisor_override);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_avg_pool2d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad, int64_t divisor_override) {
  PROTECT(
    auto outputs__ = torch::avg_pool2d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad, divisor_override);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_avg_pool2d_out(tensor *out__, tensor out, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad, int64_t divisor_override) {
  PROTECT(
    auto outputs__ = torch::avg_pool2d_out(*out, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad, divisor_override);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_avg_pool3d(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad, int64_t divisor_override) {
  PROTECT(
    auto outputs__ = torch::avg_pool3d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad, divisor_override);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_avg_pool3d_backward(tensor *out__, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad, int64_t divisor_override) {
  PROTECT(
    auto outputs__ = torch::avg_pool3d_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad, divisor_override);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_avg_pool3d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad, int64_t divisor_override) {
  PROTECT(
    auto outputs__ = torch::avg_pool3d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad, divisor_override);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_avg_pool3d_out(tensor *out__, tensor out, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int ceil_mode, int count_include_pad, int64_t divisor_override) {
  PROTECT(
    auto outputs__ = torch::avg_pool3d_out(*out, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad, divisor_override);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_baddbmm(tensor *out__, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = torch::baddbmm(*self, *batch1, *batch2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_baddbmm_(tensor *out__, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = self->baddbmm_(*batch1, *batch2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_baddbmm_out(tensor *out__, tensor out, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    auto outputs__ = torch::baddbmm_out(*out, *self, *batch1, *batch2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bartlett_window(tensor *out__, int64_t window_length, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::bartlett_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bartlett_window1(tensor *out__, int64_t window_length, int periodic, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::bartlett_window(window_length, (bool)periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_batch_norm(tensor *out__, tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double momentum, double eps, int cudnn_enabled) {
  PROTECT(
    auto outputs__ = torch::batch_norm(*input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)training, momentum, eps, (bool)cudnn_enabled);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_batch_norm_backward_elemt(tensor *out__, tensor grad_out, tensor input, tensor mean, tensor invstd, tensor weight, tensor mean_dy, tensor mean_dy_xmu) {
  PROTECT(
    auto outputs__ = torch::batch_norm_backward_elemt(*grad_out, *input, *mean, *invstd, (weight ? *weight : torch::Tensor()), *mean_dy, *mean_dy_xmu);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_batch_norm_backward_reduce(tensor *out__, tensor grad_out, tensor input, tensor mean, tensor invstd, tensor weight, int input_g, int weight_g, int bias_g) {
  PROTECT(
    auto outputs__ = torch::batch_norm_backward_reduce(*grad_out, *input, *mean, *invstd, (weight ? *weight : torch::Tensor()), (bool)input_g, (bool)weight_g, (bool)bias_g);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    out__[3] = new torch::Tensor(std::get<3>(outputs__));
  )
}

void atg_batch_norm_elemt(tensor *out__, tensor input, tensor weight, tensor bias, tensor mean, tensor invstd, double eps) {
  PROTECT(
    auto outputs__ = torch::batch_norm_elemt(*input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), *mean, *invstd, eps);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_batch_norm_elemt_out(tensor *out__, tensor out, tensor input, tensor weight, tensor bias, tensor mean, tensor invstd, double eps) {
  PROTECT(
    auto outputs__ = torch::batch_norm_elemt_out(*out, *input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), *mean, *invstd, eps);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_batch_norm_gather_stats(tensor *out__, tensor input, tensor mean, tensor invstd, tensor running_mean, tensor running_var, double momentum, double eps, int64_t count) {
  PROTECT(
    auto outputs__ = torch::batch_norm_gather_stats(*input, *mean, *invstd, (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), momentum, eps, count);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_batch_norm_gather_stats_with_counts(tensor *out__, tensor input, tensor mean, tensor invstd, tensor running_mean, tensor running_var, double momentum, double eps, int64_t *counts_data, int counts_len) {
  PROTECT(
    auto outputs__ = torch::batch_norm_gather_stats_with_counts(*input, *mean, *invstd, (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), momentum, eps, torch::IntArrayRef(counts_data, counts_len));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_batch_norm_stats(tensor *out__, tensor input, double eps) {
  PROTECT(
    auto outputs__ = torch::batch_norm_stats(*input, eps);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_batch_norm_update_stats(tensor *out__, tensor input, tensor running_mean, tensor running_var, double momentum) {
  PROTECT(
    auto outputs__ = torch::batch_norm_update_stats(*input, (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), momentum);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_bernoulli(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::bernoulli(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bernoulli1(tensor *out__, tensor self, double p) {
  PROTECT(
    auto outputs__ = torch::bernoulli(*self, p);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bernoulli_(tensor *out__, tensor self, tensor p) {
  PROTECT(
    auto outputs__ = self->bernoulli_(*p);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bernoulli_1(tensor *out__, tensor self, double p) {
  PROTECT(
    auto outputs__ = self->bernoulli_(p);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bernoulli_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::bernoulli_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bilinear(tensor *out__, tensor input1, tensor input2, tensor weight, tensor bias) {
  PROTECT(
    auto outputs__ = torch::bilinear(*input1, *input2, *weight, (bias ? *bias : torch::Tensor()));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_binary_cross_entropy(tensor *out__, tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy(*self, *target, (weight ? *weight : torch::Tensor()), reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_binary_cross_entropy_backward(tensor *out__, tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy_backward(*grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_binary_cross_entropy_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy_backward_out(*grad_input, *grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_binary_cross_entropy_out(tensor *out__, tensor out, tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy_out(*out, *self, *target, (weight ? *weight : torch::Tensor()), reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_binary_cross_entropy_with_logits(tensor *out__, tensor self, tensor target, tensor weight, tensor pos_weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy_with_logits(*self, *target, (weight ? *weight : torch::Tensor()), (pos_weight ? *pos_weight : torch::Tensor()), reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_binary_cross_entropy_with_logits_backward(tensor *out__, tensor grad_output, tensor self, tensor target, tensor weight, tensor pos_weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::binary_cross_entropy_with_logits_backward(*grad_output, *self, *target, (weight ? *weight : torch::Tensor()), (pos_weight ? *pos_weight : torch::Tensor()), reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bincount(tensor *out__, tensor self, tensor weights, int64_t minlength) {
  PROTECT(
    auto outputs__ = torch::bincount(*self, (weights ? *weights : torch::Tensor()), minlength);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_and(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::bitwise_and(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_and1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::bitwise_and(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_and_(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->bitwise_and_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_and_1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->bitwise_and_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_and_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::bitwise_and_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_and_out1(tensor *out__, tensor out, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::bitwise_and_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_not(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::bitwise_not(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_not_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->bitwise_not_();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_not_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::bitwise_not_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_or(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::bitwise_or(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_or1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::bitwise_or(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_or_(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->bitwise_or_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_or_1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->bitwise_or_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_or_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::bitwise_or_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_or_out1(tensor *out__, tensor out, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::bitwise_or_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_xor(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::bitwise_xor(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_xor1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::bitwise_xor(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_xor_(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->bitwise_xor_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_xor_1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->bitwise_xor_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_xor_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::bitwise_xor_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bitwise_xor_out1(tensor *out__, tensor out, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::bitwise_xor_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_blackman_window(tensor *out__, int64_t window_length, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::blackman_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_blackman_window1(tensor *out__, int64_t window_length, int periodic, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::blackman_window(window_length, (bool)periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bmm(tensor *out__, tensor self, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::bmm(*self, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_bmm_out(tensor *out__, tensor out, tensor self, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::bmm_out(*out, *self, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

tensor *atg_broadcast_tensors(tensor *tensors_data, int tensors_len) {
  PROTECT(
    auto outputs__ = torch::broadcast_tensors(of_carray_tensor(tensors_data, tensors_len));
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
  return nullptr;
}

void atg_cartesian_prod(tensor *out__, tensor *tensors_data, int tensors_len) {
  PROTECT(
    auto outputs__ = torch::cartesian_prod(of_carray_tensor(tensors_data, tensors_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cat(tensor *out__, tensor *tensors_data, int tensors_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cat(of_carray_tensor(tensors_data, tensors_len), dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cat_out(tensor *out__, tensor out, tensor *tensors_data, int tensors_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cat_out(*out, of_carray_tensor(tensors_data, tensors_len), dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cauchy_(tensor *out__, tensor self, double median, double sigma) {
  PROTECT(
    auto outputs__ = self->cauchy_(median, sigma);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cdist(tensor *out__, tensor x1, tensor x2, double p, int64_t compute_mode) {
  PROTECT(
    auto outputs__ = torch::cdist(*x1, *x2, p, compute_mode);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ceil(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::ceil(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ceil_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::ceil_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ceil_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::ceil_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_celu(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::celu(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_celu_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::celu_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_chain_matmul(tensor *out__, tensor *matrices_data, int matrices_len) {
  PROTECT(
    auto outputs__ = torch::chain_matmul(of_carray_tensor(matrices_data, matrices_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cholesky(tensor *out__, tensor self, int upper) {
  PROTECT(
    auto outputs__ = torch::cholesky(*self, (bool)upper);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cholesky_inverse(tensor *out__, tensor self, int upper) {
  PROTECT(
    auto outputs__ = torch::cholesky_inverse(*self, (bool)upper);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cholesky_inverse_out(tensor *out__, tensor out, tensor self, int upper) {
  PROTECT(
    auto outputs__ = torch::cholesky_inverse_out(*out, *self, (bool)upper);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cholesky_out(tensor *out__, tensor out, tensor self, int upper) {
  PROTECT(
    auto outputs__ = torch::cholesky_out(*out, *self, (bool)upper);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cholesky_solve(tensor *out__, tensor self, tensor input2, int upper) {
  PROTECT(
    auto outputs__ = torch::cholesky_solve(*self, *input2, (bool)upper);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cholesky_solve_out(tensor *out__, tensor out, tensor self, tensor input2, int upper) {
  PROTECT(
    auto outputs__ = torch::cholesky_solve_out(*out, *self, *input2, (bool)upper);
    out__[0] = new torch::Tensor(outputs__);
  )
}

tensor *atg_chunk(tensor self, int64_t chunks, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::chunk(*self, chunks, dim);
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
  return nullptr;
}

void atg_clamp(tensor *out__, tensor self, scalar min, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp(*self, *min, *max);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_clamp_(tensor *out__, tensor self, scalar min, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp_(*self, *min, *max);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_clamp_max(tensor *out__, tensor self, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp_max(*self, *max);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_clamp_max_(tensor *out__, tensor self, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp_max_(*self, *max);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_clamp_max_out(tensor *out__, tensor out, tensor self, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp_max_out(*out, *self, *max);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_clamp_min(tensor *out__, tensor self, scalar min) {
  PROTECT(
    auto outputs__ = torch::clamp_min(*self, *min);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_clamp_min_(tensor *out__, tensor self, scalar min) {
  PROTECT(
    auto outputs__ = torch::clamp_min_(*self, *min);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_clamp_min_out(tensor *out__, tensor out, tensor self, scalar min) {
  PROTECT(
    auto outputs__ = torch::clamp_min_out(*out, *self, *min);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_clamp_out(tensor *out__, tensor out, tensor self, scalar min, scalar max) {
  PROTECT(
    auto outputs__ = torch::clamp_out(*out, *self, *min, *max);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_coalesce(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->coalesce();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_col2im(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len, int64_t *kernel_size_data, int kernel_size_len, int64_t *dilation_data, int dilation_len, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len) {
  PROTECT(
    auto outputs__ = torch::col2im(*self, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_col2im_backward(tensor *out__, tensor grad_output, int64_t *kernel_size_data, int kernel_size_len, int64_t *dilation_data, int dilation_len, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len) {
  PROTECT(
    auto outputs__ = torch::col2im_backward(*grad_output, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_col2im_backward_out(tensor *out__, tensor grad_input, tensor grad_output, int64_t *kernel_size_data, int kernel_size_len, int64_t *dilation_data, int dilation_len, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len) {
  PROTECT(
    auto outputs__ = torch::col2im_backward_out(*grad_input, *grad_output, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_col2im_out(tensor *out__, tensor out, tensor self, int64_t *output_size_data, int output_size_len, int64_t *kernel_size_data, int kernel_size_len, int64_t *dilation_data, int dilation_len, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len) {
  PROTECT(
    auto outputs__ = torch::col2im_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_combinations(tensor *out__, tensor self, int64_t r, int with_replacement) {
  PROTECT(
    auto outputs__ = torch::combinations(*self, r, (bool)with_replacement);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_conj(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::conj(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_conj_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::conj_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_constant_pad_nd(tensor *out__, tensor self, int64_t *pad_data, int pad_len) {
  PROTECT(
    auto outputs__ = torch::constant_pad_nd(*self, torch::IntArrayRef(pad_data, pad_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_contiguous(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->contiguous();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_conv1d(tensor *out__, tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::conv1d(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_conv2d(tensor *out__, tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::conv2d(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_conv3d(tensor *out__, tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::conv3d(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_conv_tbc(tensor *out__, tensor self, tensor weight, tensor bias, int64_t pad) {
  PROTECT(
    auto outputs__ = torch::conv_tbc(*self, *weight, *bias, pad);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_conv_tbc_backward(tensor *out__, tensor self, tensor input, tensor weight, tensor bias, int64_t pad) {
  PROTECT(
    auto outputs__ = torch::conv_tbc_backward(*self, *input, *weight, *bias, pad);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_conv_transpose1d(tensor *out__, tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t groups, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::conv_transpose1d(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), groups, torch::IntArrayRef(dilation_data, dilation_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_conv_transpose2d(tensor *out__, tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t groups, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::conv_transpose2d(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), groups, torch::IntArrayRef(dilation_data, dilation_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_conv_transpose3d(tensor *out__, tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t groups, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::conv_transpose3d(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), groups, torch::IntArrayRef(dilation_data, dilation_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_convolution(tensor *out__, tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int transposed, int64_t *output_padding_data, int output_padding_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::convolution(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)transposed, torch::IntArrayRef(output_padding_data, output_padding_len), groups);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_convolution_overrideable(tensor *out__, tensor input, tensor weight, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int transposed, int64_t *output_padding_data, int output_padding_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::convolution_overrideable(*input, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)transposed, torch::IntArrayRef(output_padding_data, output_padding_len), groups);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_copy_sparse_to_sparse_(tensor *out__, tensor self, tensor src, int non_blocking) {
  PROTECT(
    auto outputs__ = torch::copy_sparse_to_sparse_(*self, *src, (bool)non_blocking);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cos(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::cos(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cos_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::cos_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cos_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::cos_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cosh(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::cosh(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cosh_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::cosh_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cosh_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::cosh_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cosine_embedding_loss(tensor *out__, tensor input1, tensor input2, tensor target, double margin, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::cosine_embedding_loss(*input1, *input2, *target, margin, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cosine_similarity(tensor *out__, tensor x1, tensor x2, int64_t dim, double eps) {
  PROTECT(
    auto outputs__ = torch::cosine_similarity(*x1, *x2, dim, eps);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cross(tensor *out__, tensor self, tensor other, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cross(*self, *other, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cross_out(tensor *out__, tensor out, tensor self, tensor other, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cross_out(*out, *self, *other, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ctc_loss(tensor *out__, tensor log_probs, tensor targets, int64_t *input_lengths_data, int input_lengths_len, int64_t *target_lengths_data, int target_lengths_len, int64_t blank, int64_t reduction, int zero_infinity) {
  PROTECT(
    auto outputs__ = torch::ctc_loss(*log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), blank, reduction, (bool)zero_infinity);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ctc_loss1(tensor *out__, tensor log_probs, tensor targets, tensor input_lengths, tensor target_lengths, int64_t blank, int64_t reduction, int zero_infinity) {
  PROTECT(
    auto outputs__ = torch::ctc_loss(*log_probs, *targets, *input_lengths, *target_lengths, blank, reduction, (bool)zero_infinity);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_affine_grid_generator(tensor *out__, tensor theta, int64_t n, int64_t C, int64_t H, int64_t W) {
  PROTECT(
    auto outputs__ = torch::cudnn_affine_grid_generator(*theta, n, C, H, W);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_affine_grid_generator_backward(tensor *out__, tensor grad, int64_t n, int64_t C, int64_t H, int64_t W) {
  PROTECT(
    auto outputs__ = torch::cudnn_affine_grid_generator_backward(*grad, n, C, H, W);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_batch_norm(tensor *out__, tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double exponential_average_factor, double epsilon) {
  PROTECT(
    auto outputs__ = torch::cudnn_batch_norm(*input, *weight, (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)training, exponential_average_factor, epsilon);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    out__[3] = new torch::Tensor(std::get<3>(outputs__));
  )
}

void atg_cudnn_batch_norm_backward(tensor *out__, tensor input, tensor grad_output, tensor weight, tensor running_mean, tensor running_var, tensor save_mean, tensor save_var, double epsilon, tensor reserveSpace) {
  PROTECT(
    auto outputs__ = torch::cudnn_batch_norm_backward(*input, *grad_output, *weight, (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (save_mean ? *save_mean : torch::Tensor()), (save_var ? *save_var : torch::Tensor()), epsilon, *reserveSpace);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_cudnn_convolution(tensor *out__, tensor self, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution(*self, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_convolution1(tensor *out__, tensor self, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution(*self, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_convolution_backward_input(tensor *out__, int64_t *self_size_data, int self_size_len, tensor grad_output, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_backward_input(torch::IntArrayRef(self_size_data, self_size_len), *grad_output, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_convolution_backward_weight(tensor *out__, int64_t *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_backward_weight(torch::IntArrayRef(weight_size_data, weight_size_len), *grad_output, *self, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_convolution_transpose(tensor *out__, tensor self, tensor weight, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_transpose(*self, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_convolution_transpose1(tensor *out__, tensor self, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_transpose(*self, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_convolution_transpose_backward_input(tensor *out__, tensor grad_output, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_transpose_backward_input(*grad_output, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_convolution_transpose_backward_weight(tensor *out__, int64_t *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::cudnn_convolution_transpose_backward_weight(torch::IntArrayRef(weight_size_data, weight_size_len), *grad_output, *self, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_grid_sampler(tensor *out__, tensor self, tensor grid) {
  PROTECT(
    auto outputs__ = torch::cudnn_grid_sampler(*self, *grid);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cudnn_grid_sampler_backward(tensor *out__, tensor self, tensor grid, tensor grad_output) {
  PROTECT(
    auto outputs__ = torch::cudnn_grid_sampler_backward(*self, *grid, *grad_output);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_cummax(tensor *out__, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cummax(*self, dim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_cummax_out(tensor *out__, tensor values, tensor indices, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cummax_out(*values, *indices, *self, dim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_cummin(tensor *out__, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cummin(*self, dim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_cummin_out(tensor *out__, tensor values, tensor indices, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::cummin_out(*values, *indices, *self, dim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_cumprod(tensor *out__, tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::cumprod(*self, dim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cumprod_out(tensor *out__, tensor out, tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::cumprod_out(*out, *self, dim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cumsum(tensor *out__, tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::cumsum(*self, dim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_cumsum_out(tensor *out__, tensor out, tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::cumsum_out(*out, *self, dim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_data(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->data();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_dequantize(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::dequantize(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_det(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::det(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_detach(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::detach(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_detach_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::detach_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_diag(tensor *out__, tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::diag(*self, diagonal);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_diag_embed(tensor *out__, tensor self, int64_t offset, int64_t dim1, int64_t dim2) {
  PROTECT(
    auto outputs__ = torch::diag_embed(*self, offset, dim1, dim2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_diag_out(tensor *out__, tensor out, tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::diag_out(*out, *self, diagonal);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_diagflat(tensor *out__, tensor self, int64_t offset) {
  PROTECT(
    auto outputs__ = torch::diagflat(*self, offset);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_diagonal(tensor *out__, tensor self, int64_t offset, int64_t dim1, int64_t dim2) {
  PROTECT(
    auto outputs__ = torch::diagonal(*self, offset, dim1, dim2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_digamma(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::digamma(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_digamma_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->digamma_();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_digamma_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::digamma_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_dist(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::dist(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_div(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::div(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_div1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::div(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_div_(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->div_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_div_1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->div_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_div_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::div_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_dot(tensor *out__, tensor self, tensor tensor) {
  PROTECT(
    auto outputs__ = torch::dot(*self, *tensor);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_dot_out(tensor *out__, tensor out, tensor self, tensor tensor) {
  PROTECT(
    auto outputs__ = torch::dot_out(*out, *self, *tensor);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_dropout(tensor *out__, tensor input, double p, int train) {
  PROTECT(
    auto outputs__ = torch::dropout(*input, p, (bool)train);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_dropout_(tensor *out__, tensor self, double p, int train) {
  PROTECT(
    auto outputs__ = torch::dropout_(*self, p, (bool)train);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_eig(tensor *out__, tensor self, int eigenvectors) {
  PROTECT(
    auto outputs__ = torch::eig(*self, (bool)eigenvectors);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_eig_out(tensor *out__, tensor e, tensor v, tensor self, int eigenvectors) {
  PROTECT(
    auto outputs__ = torch::eig_out(*e, *v, *self, (bool)eigenvectors);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_einsum(tensor *out__, char* equation_ptr, int equation_len, tensor *tensors_data, int tensors_len) {
  PROTECT(
    auto outputs__ = torch::einsum(std::string(equation_ptr, equation_len), of_carray_tensor(tensors_data, tensors_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_elu(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::elu(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_elu_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::elu_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_elu_backward(tensor *out__, tensor grad_output, scalar alpha, scalar scale, scalar input_scale, tensor output) {
  PROTECT(
    auto outputs__ = torch::elu_backward(*grad_output, *alpha, *scale, *input_scale, *output);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_elu_backward_out(tensor *out__, tensor grad_input, tensor grad_output, scalar alpha, scalar scale, scalar input_scale, tensor output) {
  PROTECT(
    auto outputs__ = torch::elu_backward_out(*grad_input, *grad_output, *alpha, *scale, *input_scale, *output);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_elu_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::elu_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_embedding(tensor *out__, tensor weight, tensor indices, int64_t padding_idx, int scale_grad_by_freq, int sparse) {
  PROTECT(
    auto outputs__ = torch::embedding(*weight, *indices, padding_idx, (bool)scale_grad_by_freq, (bool)sparse);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_embedding_backward(tensor *out__, tensor grad, tensor indices, int64_t num_weights, int64_t padding_idx, int scale_grad_by_freq, int sparse) {
  PROTECT(
    auto outputs__ = torch::embedding_backward(*grad, *indices, num_weights, padding_idx, (bool)scale_grad_by_freq, (bool)sparse);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_embedding_bag(tensor *out__, tensor weight, tensor indices, tensor offsets, int scale_grad_by_freq, int64_t mode, int sparse, tensor per_sample_weights, int include_last_offset) {
  PROTECT(
    auto outputs__ = torch::embedding_bag(*weight, *indices, *offsets, (bool)scale_grad_by_freq, mode, (bool)sparse, (per_sample_weights ? *per_sample_weights : torch::Tensor()), (bool)include_last_offset);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    out__[3] = new torch::Tensor(std::get<3>(outputs__));
  )
}

void atg_embedding_dense_backward(tensor *out__, tensor grad_output, tensor indices, int64_t num_weights, int64_t padding_idx, int scale_grad_by_freq) {
  PROTECT(
    auto outputs__ = torch::embedding_dense_backward(*grad_output, *indices, num_weights, padding_idx, (bool)scale_grad_by_freq);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_embedding_renorm_(tensor *out__, tensor self, tensor indices, double max_norm, double norm_type) {
  PROTECT(
    auto outputs__ = torch::embedding_renorm_(*self, *indices, max_norm, norm_type);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_embedding_sparse_backward(tensor *out__, tensor grad, tensor indices, int64_t num_weights, int64_t padding_idx, int scale_grad_by_freq) {
  PROTECT(
    auto outputs__ = torch::embedding_sparse_backward(*grad, *indices, num_weights, padding_idx, (bool)scale_grad_by_freq);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_empty(tensor *out__, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::empty(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_empty_like(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::empty_like(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_empty_out(tensor *out__, tensor out, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::empty_out(*out, torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_empty_strided(tensor *out__, int64_t *size_data, int size_len, int64_t *stride_data, int stride_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::empty_strided(torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_eq(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::eq(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_eq1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::eq(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_eq_(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->eq_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_eq_1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->eq_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_eq_out(tensor *out__, tensor out, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::eq_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_eq_out1(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::eq_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_erf(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::erf(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_erf_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::erf_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_erf_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::erf_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_erfc(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::erfc(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_erfc_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::erfc_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_erfc_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::erfc_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_erfinv(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::erfinv(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_erfinv_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->erfinv_();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_erfinv_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::erfinv_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_exp(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::exp(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_exp_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::exp_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_exp_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::exp_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_expand(tensor *out__, tensor self, int64_t *size_data, int size_len, int implicit) {
  PROTECT(
    auto outputs__ = self->expand(torch::IntArrayRef(size_data, size_len), (bool)implicit);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_expand_as(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->expand_as(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_expm1(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::expm1(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_expm1_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::expm1_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_expm1_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::expm1_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_exponential_(tensor *out__, tensor self, double lambd) {
  PROTECT(
    auto outputs__ = self->exponential_(lambd);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_eye(tensor *out__, int64_t n, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::eye(n, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_eye1(tensor *out__, int64_t n, int64_t m, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::eye(n, m, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_eye_out(tensor *out__, tensor out, int64_t n) {
  PROTECT(
    auto outputs__ = torch::eye_out(*out, n);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_eye_out1(tensor *out__, tensor out, int64_t n, int64_t m) {
  PROTECT(
    auto outputs__ = torch::eye_out(*out, n, m);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fake_quantize_per_channel_affine(tensor *out__, tensor self, tensor scale, tensor zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
  PROTECT(
    auto outputs__ = torch::fake_quantize_per_channel_affine(*self, *scale, *zero_point, axis, quant_min, quant_max);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fake_quantize_per_channel_affine_backward(tensor *out__, tensor grad, tensor self, tensor scale, tensor zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
  PROTECT(
    auto outputs__ = torch::fake_quantize_per_channel_affine_backward(*grad, *self, *scale, *zero_point, axis, quant_min, quant_max);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fake_quantize_per_tensor_affine(tensor *out__, tensor self, double scale, int64_t zero_point, int64_t quant_min, int64_t quant_max) {
  PROTECT(
    auto outputs__ = torch::fake_quantize_per_tensor_affine(*self, scale, zero_point, quant_min, quant_max);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fake_quantize_per_tensor_affine_backward(tensor *out__, tensor grad, tensor self, double scale, int64_t zero_point, int64_t quant_min, int64_t quant_max) {
  PROTECT(
    auto outputs__ = torch::fake_quantize_per_tensor_affine_backward(*grad, *self, scale, zero_point, quant_min, quant_max);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fbgemm_linear_fp16_weight(tensor *out__, tensor input, tensor packed_weight, tensor bias) {
  PROTECT(
    auto outputs__ = torch::fbgemm_linear_fp16_weight(*input, *packed_weight, *bias);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fbgemm_linear_fp16_weight_fp32_activation(tensor *out__, tensor input, tensor packed_weight, tensor bias) {
  PROTECT(
    auto outputs__ = torch::fbgemm_linear_fp16_weight_fp32_activation(*input, *packed_weight, *bias);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fbgemm_linear_int8_weight(tensor *out__, tensor input, tensor weight, tensor packed, tensor col_offsets, scalar weight_scale, scalar weight_zero_point, tensor bias) {
  PROTECT(
    auto outputs__ = torch::fbgemm_linear_int8_weight(*input, *weight, *packed, *col_offsets, *weight_scale, *weight_zero_point, *bias);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fbgemm_linear_int8_weight_fp32_activation(tensor *out__, tensor input, tensor weight, tensor packed, tensor col_offsets, scalar weight_scale, scalar weight_zero_point, tensor bias) {
  PROTECT(
    auto outputs__ = torch::fbgemm_linear_int8_weight_fp32_activation(*input, *weight, *packed, *col_offsets, *weight_scale, *weight_zero_point, *bias);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fbgemm_pack_gemm_matrix_fp16(tensor *out__, tensor input) {
  PROTECT(
    auto outputs__ = torch::fbgemm_pack_gemm_matrix_fp16(*input);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fbgemm_pack_quantized_matrix(tensor *out__, tensor input) {
  PROTECT(
    auto outputs__ = torch::fbgemm_pack_quantized_matrix(*input);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fbgemm_pack_quantized_matrix1(tensor *out__, tensor input, int64_t K, int64_t n) {
  PROTECT(
    auto outputs__ = torch::fbgemm_pack_quantized_matrix(*input, K, n);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_feature_alpha_dropout(tensor *out__, tensor input, double p, int train) {
  PROTECT(
    auto outputs__ = torch::feature_alpha_dropout(*input, p, (bool)train);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_feature_alpha_dropout_(tensor *out__, tensor self, double p, int train) {
  PROTECT(
    auto outputs__ = torch::feature_alpha_dropout_(*self, p, (bool)train);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_feature_dropout(tensor *out__, tensor input, double p, int train) {
  PROTECT(
    auto outputs__ = torch::feature_dropout(*input, p, (bool)train);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_feature_dropout_(tensor *out__, tensor self, double p, int train) {
  PROTECT(
    auto outputs__ = torch::feature_dropout_(*self, p, (bool)train);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fft(tensor *out__, tensor self, int64_t signal_ndim, int normalized) {
  PROTECT(
    auto outputs__ = torch::fft(*self, signal_ndim, (bool)normalized);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fill_(tensor *out__, tensor self, scalar value) {
  PROTECT(
    auto outputs__ = torch::fill_(*self, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fill_1(tensor *out__, tensor self, tensor value) {
  PROTECT(
    auto outputs__ = torch::fill_(*self, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fill_diagonal_(tensor *out__, tensor self, scalar fill_value, int wrap) {
  PROTECT(
    auto outputs__ = self->fill_diagonal_(*fill_value, (bool)wrap);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_flatten(tensor *out__, tensor self, int64_t start_dim, int64_t end_dim) {
  PROTECT(
    auto outputs__ = torch::flatten(*self, start_dim, end_dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_flip(tensor *out__, tensor self, int64_t *dims_data, int dims_len) {
  PROTECT(
    auto outputs__ = torch::flip(*self, torch::IntArrayRef(dims_data, dims_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_floor(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::floor(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_floor_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::floor_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_floor_divide(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::floor_divide(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_floor_divide1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::floor_divide(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_floor_divide_(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->floor_divide_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_floor_divide_1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->floor_divide_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_floor_divide_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::floor_divide_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_floor_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::floor_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fmod(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::fmod(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fmod1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::fmod(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fmod_(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->fmod_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fmod_1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->fmod_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fmod_out(tensor *out__, tensor out, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::fmod_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fmod_out1(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::fmod_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_frac(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::frac(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_frac_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::frac_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_frac_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::frac_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fractional_max_pool2d(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor random_samples) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool2d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *random_samples);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_fractional_max_pool2d_backward(tensor *out__, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor indices) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool2d_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fractional_max_pool2d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor indices) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool2d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fractional_max_pool2d_out(tensor *out__, tensor output, tensor indices, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor random_samples) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool2d_out(*output, *indices, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *random_samples);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_fractional_max_pool3d(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor random_samples) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool3d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *random_samples);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_fractional_max_pool3d_backward(tensor *out__, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor indices) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool3d_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fractional_max_pool3d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor indices) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool3d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_fractional_max_pool3d_out(tensor *out__, tensor output, tensor indices, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *output_size_data, int output_size_len, tensor random_samples) {
  PROTECT(
    auto outputs__ = torch::fractional_max_pool3d_out(*output, *indices, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *random_samples);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_frobenius_norm(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::frobenius_norm(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_frobenius_norm1(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::frobenius_norm(*self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_frobenius_norm_out(tensor *out__, tensor out, tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::frobenius_norm_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_from_file(tensor *out__, char* filename_ptr, int filename_len, int shared, int64_t size, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::from_file(std::string(filename_ptr, filename_len), (bool)shared, size, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_full(tensor *out__, int64_t *size_data, int size_len, scalar fill_value, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::full(torch::IntArrayRef(size_data, size_len), *fill_value, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_full_like(tensor *out__, tensor self, scalar fill_value) {
  PROTECT(
    auto outputs__ = torch::full_like(*self, *fill_value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_full_out(tensor *out__, tensor out, int64_t *size_data, int size_len, scalar fill_value) {
  PROTECT(
    auto outputs__ = torch::full_out(*out, torch::IntArrayRef(size_data, size_len), *fill_value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_gather(tensor *out__, tensor self, int64_t dim, tensor index, int sparse_grad) {
  PROTECT(
    auto outputs__ = torch::gather(*self, dim, *index, (bool)sparse_grad);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_gather_out(tensor *out__, tensor out, tensor self, int64_t dim, tensor index, int sparse_grad) {
  PROTECT(
    auto outputs__ = torch::gather_out(*out, *self, dim, *index, (bool)sparse_grad);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ge(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::ge(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ge1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::ge(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ge_(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->ge_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ge_1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->ge_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ge_out(tensor *out__, tensor out, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::ge_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ge_out1(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::ge_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_gelu(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::gelu(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_gelu_backward(tensor *out__, tensor grad, tensor self) {
  PROTECT(
    auto outputs__ = torch::gelu_backward(*grad, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_geometric_(tensor *out__, tensor self, double p) {
  PROTECT(
    auto outputs__ = self->geometric_(p);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_geqrf(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::geqrf(*self);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_geqrf_out(tensor *out__, tensor a, tensor tau, tensor self) {
  PROTECT(
    auto outputs__ = torch::geqrf_out(*a, *tau, *self);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_ger(tensor *out__, tensor self, tensor vec2) {
  PROTECT(
    auto outputs__ = torch::ger(*self, *vec2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ger_out(tensor *out__, tensor out, tensor self, tensor vec2) {
  PROTECT(
    auto outputs__ = torch::ger_out(*out, *self, *vec2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_glu(tensor *out__, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::glu(*self, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_glu_backward(tensor *out__, tensor grad_output, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::glu_backward(*grad_output, *self, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_glu_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::glu_backward_out(*grad_input, *grad_output, *self, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_glu_out(tensor *out__, tensor out, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::glu_out(*out, *self, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_grad(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->grad();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_grid_sampler(tensor *out__, tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode, int align_corners) {
  PROTECT(
    auto outputs__ = torch::grid_sampler(*input, *grid, interpolation_mode, padding_mode, (bool)align_corners);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_grid_sampler_2d(tensor *out__, tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode, int align_corners) {
  PROTECT(
    auto outputs__ = torch::grid_sampler_2d(*input, *grid, interpolation_mode, padding_mode, (bool)align_corners);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_grid_sampler_2d_backward(tensor *out__, tensor grad_output, tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode, int align_corners) {
  PROTECT(
    auto outputs__ = torch::grid_sampler_2d_backward(*grad_output, *input, *grid, interpolation_mode, padding_mode, (bool)align_corners);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_grid_sampler_3d(tensor *out__, tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode, int align_corners) {
  PROTECT(
    auto outputs__ = torch::grid_sampler_3d(*input, *grid, interpolation_mode, padding_mode, (bool)align_corners);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_grid_sampler_3d_backward(tensor *out__, tensor grad_output, tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode, int align_corners) {
  PROTECT(
    auto outputs__ = torch::grid_sampler_3d_backward(*grad_output, *input, *grid, interpolation_mode, padding_mode, (bool)align_corners);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_group_norm(tensor *out__, tensor input, int64_t num_groups, tensor weight, tensor bias, double eps, int cudnn_enabled) {
  PROTECT(
    auto outputs__ = torch::group_norm(*input, num_groups, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), eps, (bool)cudnn_enabled);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_gru(tensor *out__, tensor input, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional, int batch_first) {
  PROTECT(
    auto outputs__ = torch::gru(*input, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional, (bool)batch_first);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_gru1(tensor *out__, tensor data, tensor batch_sizes, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional) {
  PROTECT(
    auto outputs__ = torch::gru(*data, *batch_sizes, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_gru_cell(tensor *out__, tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh) {
  PROTECT(
    auto outputs__ = torch::gru_cell(*input, *hx, *w_ih, *w_hh, (b_ih ? *b_ih : torch::Tensor()), (b_hh ? *b_hh : torch::Tensor()));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_gt(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::gt(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_gt1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::gt(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_gt_(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->gt_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_gt_1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->gt_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_gt_out(tensor *out__, tensor out, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::gt_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_gt_out1(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::gt_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hamming_window(tensor *out__, int64_t window_length, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hamming_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hamming_window1(tensor *out__, int64_t window_length, int periodic, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hamming_window(window_length, (bool)periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hamming_window2(tensor *out__, int64_t window_length, int periodic, double alpha, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hamming_window(window_length, (bool)periodic, alpha, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hamming_window3(tensor *out__, int64_t window_length, int periodic, double alpha, double beta, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hamming_window(window_length, (bool)periodic, alpha, beta, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hann_window(tensor *out__, int64_t window_length, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hann_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hann_window1(tensor *out__, int64_t window_length, int periodic, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::hann_window(window_length, (bool)periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hardshrink(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::hardshrink(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hardshrink_backward(tensor *out__, tensor grad_out, tensor self, scalar lambd) {
  PROTECT(
    auto outputs__ = torch::hardshrink_backward(*grad_out, *self, *lambd);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hardsigmoid(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::hardsigmoid(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hardsigmoid_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::hardsigmoid_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hardsigmoid_backward(tensor *out__, tensor grad_output, tensor self) {
  PROTECT(
    auto outputs__ = torch::hardsigmoid_backward(*grad_output, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hardsigmoid_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::hardsigmoid_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hardtanh(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::hardtanh(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hardtanh_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::hardtanh_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hardtanh_backward(tensor *out__, tensor grad_output, tensor self, scalar min_val, scalar max_val) {
  PROTECT(
    auto outputs__ = torch::hardtanh_backward(*grad_output, *self, *min_val, *max_val);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hardtanh_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, scalar min_val, scalar max_val) {
  PROTECT(
    auto outputs__ = torch::hardtanh_backward_out(*grad_input, *grad_output, *self, *min_val, *max_val);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hardtanh_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::hardtanh_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hinge_embedding_loss(tensor *out__, tensor self, tensor target, double margin, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::hinge_embedding_loss(*self, *target, margin, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_histc(tensor *out__, tensor self, int64_t bins) {
  PROTECT(
    auto outputs__ = torch::histc(*self, bins);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_histc_out(tensor *out__, tensor out, tensor self, int64_t bins) {
  PROTECT(
    auto outputs__ = torch::histc_out(*out, *self, bins);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hspmm(tensor *out__, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::hspmm(*mat1, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_hspmm_out(tensor *out__, tensor out, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::hspmm_out(*out, *mat1, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ifft(tensor *out__, tensor self, int64_t signal_ndim, int normalized) {
  PROTECT(
    auto outputs__ = torch::ifft(*self, signal_ndim, (bool)normalized);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_im2col(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *dilation_data, int dilation_len, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len) {
  PROTECT(
    auto outputs__ = torch::im2col(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_im2col_backward(tensor *out__, tensor grad_output, int64_t *input_size_data, int input_size_len, int64_t *kernel_size_data, int kernel_size_len, int64_t *dilation_data, int dilation_len, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len) {
  PROTECT(
    auto outputs__ = torch::im2col_backward(*grad_output, torch::IntArrayRef(input_size_data, input_size_len), torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_im2col_backward_out(tensor *out__, tensor grad_input, tensor grad_output, int64_t *input_size_data, int input_size_len, int64_t *kernel_size_data, int kernel_size_len, int64_t *dilation_data, int dilation_len, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len) {
  PROTECT(
    auto outputs__ = torch::im2col_backward_out(*grad_input, *grad_output, torch::IntArrayRef(input_size_data, input_size_len), torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_im2col_out(tensor *out__, tensor out, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *dilation_data, int dilation_len, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len) {
  PROTECT(
    auto outputs__ = torch::im2col_out(*out, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_imag(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::imag(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index(tensor *out__, tensor self, tensor *indices_data, int indices_len) {
  PROTECT(
    auto outputs__ = torch::index(*self, of_carray_tensor(indices_data, indices_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_add(tensor *out__, tensor self, int64_t dim, tensor index, tensor source) {
  PROTECT(
    auto outputs__ = torch::index_add(*self, dim, *index, *source);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_add_(tensor *out__, tensor self, int64_t dim, tensor index, tensor source) {
  PROTECT(
    auto outputs__ = self->index_add_(dim, *index, *source);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_copy(tensor *out__, tensor self, int64_t dim, tensor index, tensor source) {
  PROTECT(
    auto outputs__ = torch::index_copy(*self, dim, *index, *source);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_copy_(tensor *out__, tensor self, int64_t dim, tensor index, tensor source) {
  PROTECT(
    auto outputs__ = self->index_copy_(dim, *index, *source);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_fill(tensor *out__, tensor self, int64_t dim, tensor index, scalar value) {
  PROTECT(
    auto outputs__ = torch::index_fill(*self, dim, *index, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_fill1(tensor *out__, tensor self, int64_t dim, tensor index, tensor value) {
  PROTECT(
    auto outputs__ = torch::index_fill(*self, dim, *index, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_fill_(tensor *out__, tensor self, int64_t dim, tensor index, scalar value) {
  PROTECT(
    auto outputs__ = self->index_fill_(dim, *index, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_fill_1(tensor *out__, tensor self, int64_t dim, tensor index, tensor value) {
  PROTECT(
    auto outputs__ = self->index_fill_(dim, *index, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_put(tensor *out__, tensor self, tensor *indices_data, int indices_len, tensor values, int accumulate) {
  PROTECT(
    auto outputs__ = torch::index_put(*self, of_carray_tensor(indices_data, indices_len), *values, (bool)accumulate);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_put_(tensor *out__, tensor self, tensor *indices_data, int indices_len, tensor values, int accumulate) {
  PROTECT(
    auto outputs__ = torch::index_put_(*self, of_carray_tensor(indices_data, indices_len), *values, (bool)accumulate);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_select(tensor *out__, tensor self, int64_t dim, tensor index) {
  PROTECT(
    auto outputs__ = torch::index_select(*self, dim, *index);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_index_select_out(tensor *out__, tensor out, tensor self, int64_t dim, tensor index) {
  PROTECT(
    auto outputs__ = torch::index_select_out(*out, *self, dim, *index);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_indices(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->indices();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_instance_norm(tensor *out__, tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int use_input_stats, double momentum, double eps, int cudnn_enabled) {
  PROTECT(
    auto outputs__ = torch::instance_norm(*input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)use_input_stats, momentum, eps, (bool)cudnn_enabled);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_int_repr(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::int_repr(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_inverse(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::inverse(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_inverse_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::inverse_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_irfft(tensor *out__, tensor self, int64_t signal_ndim, int normalized, int onesided, int64_t *signal_sizes_data, int signal_sizes_len) {
  PROTECT(
    auto outputs__ = torch::irfft(*self, signal_ndim, (bool)normalized, (bool)onesided, torch::IntArrayRef(signal_sizes_data, signal_sizes_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_isclose(tensor *out__, tensor self, tensor other, double rtol, double atol, int equal_nan) {
  PROTECT(
    auto outputs__ = torch::isclose(*self, *other, rtol, atol, (bool)equal_nan);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_isfinite(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::isfinite(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_isinf(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::isinf(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_isnan(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::isnan(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_kl_div(tensor *out__, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::kl_div(*self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_kl_div_backward(tensor *out__, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::kl_div_backward(*grad_output, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_kthvalue(tensor *out__, tensor self, int64_t k, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::kthvalue(*self, k, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_kthvalue_out(tensor *out__, tensor values, tensor indices, tensor self, int64_t k, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::kthvalue_out(*values, *indices, *self, k, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_l1_loss(tensor *out__, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::l1_loss(*self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_l1_loss_backward(tensor *out__, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::l1_loss_backward(*grad_output, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_l1_loss_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::l1_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_l1_loss_out(tensor *out__, tensor out, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::l1_loss_out(*out, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_layer_norm(tensor *out__, tensor input, int64_t *normalized_shape_data, int normalized_shape_len, tensor weight, tensor bias, double eps, int cudnn_enable) {
  PROTECT(
    auto outputs__ = torch::layer_norm(*input, torch::IntArrayRef(normalized_shape_data, normalized_shape_len), (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), eps, (bool)cudnn_enable);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_le(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::le(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_le1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::le(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_le_(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->le_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_le_1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->le_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_le_out(tensor *out__, tensor out, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::le_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_le_out1(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::le_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_leaky_relu(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::leaky_relu(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_leaky_relu_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::leaky_relu_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_leaky_relu_backward(tensor *out__, tensor grad_output, tensor self, scalar negative_slope, int self_is_result) {
  PROTECT(
    auto outputs__ = torch::leaky_relu_backward(*grad_output, *self, *negative_slope, (bool)self_is_result);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_leaky_relu_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::leaky_relu_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lerp(tensor *out__, tensor self, tensor end, scalar weight) {
  PROTECT(
    auto outputs__ = torch::lerp(*self, *end, *weight);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lerp1(tensor *out__, tensor self, tensor end, tensor weight) {
  PROTECT(
    auto outputs__ = torch::lerp(*self, *end, *weight);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lerp_(tensor *out__, tensor self, tensor end, scalar weight) {
  PROTECT(
    auto outputs__ = self->lerp_(*end, *weight);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lerp_1(tensor *out__, tensor self, tensor end, tensor weight) {
  PROTECT(
    auto outputs__ = self->lerp_(*end, *weight);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lerp_out(tensor *out__, tensor out, tensor self, tensor end, scalar weight) {
  PROTECT(
    auto outputs__ = torch::lerp_out(*out, *self, *end, *weight);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lerp_out1(tensor *out__, tensor out, tensor self, tensor end, tensor weight) {
  PROTECT(
    auto outputs__ = torch::lerp_out(*out, *self, *end, *weight);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lgamma(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::lgamma(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lgamma_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->lgamma_();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lgamma_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::lgamma_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_linear(tensor *out__, tensor input, tensor weight, tensor bias) {
  PROTECT(
    auto outputs__ = torch::linear(*input, *weight, (bias ? *bias : torch::Tensor()));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_linspace(tensor *out__, scalar start, scalar end, int64_t steps, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::linspace(*start, *end, steps, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_linspace_out(tensor *out__, tensor out, scalar start, scalar end, int64_t steps) {
  PROTECT(
    auto outputs__ = torch::linspace_out(*out, *start, *end, steps);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::log(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log10(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::log10(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log10_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::log10_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log10_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::log10_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log1p(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::log1p(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log1p_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::log1p_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log1p_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::log1p_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log2(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::log2(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log2_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::log2_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log2_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::log2_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::log_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log_normal_(tensor *out__, tensor self, double mean, double std) {
  PROTECT(
    auto outputs__ = self->log_normal_(mean, std);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::log_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log_sigmoid(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::log_sigmoid(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log_sigmoid_backward(tensor *out__, tensor grad_output, tensor self, tensor buffer) {
  PROTECT(
    auto outputs__ = torch::log_sigmoid_backward(*grad_output, *self, *buffer);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log_sigmoid_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor buffer) {
  PROTECT(
    auto outputs__ = torch::log_sigmoid_backward_out(*grad_input, *grad_output, *self, *buffer);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log_sigmoid_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::log_sigmoid_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_log_softmax(tensor *out__, tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::log_softmax(*self, dim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logdet(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::logdet(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_and(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::logical_and(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_and_(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->logical_and_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_and_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::logical_and_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_not(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::logical_not(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_not_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->logical_not_();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_not_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::logical_not_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_or(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::logical_or(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_or_(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->logical_or_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_or_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::logical_or_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_xor(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::logical_xor(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_xor_(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->logical_xor_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logical_xor_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::logical_xor_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logspace(tensor *out__, scalar start, scalar end, int64_t steps, double base, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::logspace(*start, *end, steps, base, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logspace_out(tensor *out__, tensor out, scalar start, scalar end, int64_t steps, double base) {
  PROTECT(
    auto outputs__ = torch::logspace_out(*out, *start, *end, steps, base);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logsumexp(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::logsumexp(*self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_logsumexp_out(tensor *out__, tensor out, tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::logsumexp_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lstm(tensor *out__, tensor input, tensor *hx_data, int hx_len, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional, int batch_first) {
  PROTECT(
    auto outputs__ = torch::lstm(*input, of_carray_tensor(hx_data, hx_len), of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional, (bool)batch_first);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_lstm1(tensor *out__, tensor data, tensor batch_sizes, tensor *hx_data, int hx_len, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional) {
  PROTECT(
    auto outputs__ = torch::lstm(*data, *batch_sizes, of_carray_tensor(hx_data, hx_len), of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_lstm_cell(tensor *out__, tensor input, tensor *hx_data, int hx_len, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh) {
  PROTECT(
    auto outputs__ = torch::lstm_cell(*input, of_carray_tensor(hx_data, hx_len), *w_ih, *w_hh, (b_ih ? *b_ih : torch::Tensor()), (b_hh ? *b_hh : torch::Tensor()));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_lstsq(tensor *out__, tensor self, tensor A) {
  PROTECT(
    auto outputs__ = torch::lstsq(*self, *A);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_lstsq_out(tensor *out__, tensor X, tensor qr, tensor self, tensor A) {
  PROTECT(
    auto outputs__ = torch::lstsq_out(*X, *qr, *self, *A);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_lt(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::lt(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lt1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::lt(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lt_(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->lt_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lt_1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->lt_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lt_out(tensor *out__, tensor out, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::lt_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lt_out1(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::lt_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lu_solve(tensor *out__, tensor self, tensor LU_data, tensor LU_pivots) {
  PROTECT(
    auto outputs__ = torch::lu_solve(*self, *LU_data, *LU_pivots);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_lu_solve_out(tensor *out__, tensor out, tensor self, tensor LU_data, tensor LU_pivots) {
  PROTECT(
    auto outputs__ = torch::lu_solve_out(*out, *self, *LU_data, *LU_pivots);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_margin_ranking_loss(tensor *out__, tensor input1, tensor input2, tensor target, double margin, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::margin_ranking_loss(*input1, *input2, *target, margin, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_masked_fill(tensor *out__, tensor self, tensor mask, scalar value) {
  PROTECT(
    auto outputs__ = torch::masked_fill(*self, *mask, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_masked_fill1(tensor *out__, tensor self, tensor mask, tensor value) {
  PROTECT(
    auto outputs__ = torch::masked_fill(*self, *mask, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_masked_fill_(tensor *out__, tensor self, tensor mask, scalar value) {
  PROTECT(
    auto outputs__ = self->masked_fill_(*mask, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_masked_fill_1(tensor *out__, tensor self, tensor mask, tensor value) {
  PROTECT(
    auto outputs__ = self->masked_fill_(*mask, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_masked_scatter(tensor *out__, tensor self, tensor mask, tensor source) {
  PROTECT(
    auto outputs__ = torch::masked_scatter(*self, *mask, *source);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_masked_scatter_(tensor *out__, tensor self, tensor mask, tensor source) {
  PROTECT(
    auto outputs__ = self->masked_scatter_(*mask, *source);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_masked_select(tensor *out__, tensor self, tensor mask) {
  PROTECT(
    auto outputs__ = torch::masked_select(*self, *mask);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_masked_select_out(tensor *out__, tensor out, tensor self, tensor mask) {
  PROTECT(
    auto outputs__ = torch::masked_select_out(*out, *self, *mask);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_matmul(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::matmul(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_matmul_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::matmul_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_matrix_power(tensor *out__, tensor self, int64_t n) {
  PROTECT(
    auto outputs__ = torch::matrix_power(*self, n);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_matrix_rank(tensor *out__, tensor self, int symmetric) {
  PROTECT(
    auto outputs__ = torch::matrix_rank(*self, (bool)symmetric);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_matrix_rank1(tensor *out__, tensor self, double tol, int symmetric) {
  PROTECT(
    auto outputs__ = torch::matrix_rank(*self, tol, (bool)symmetric);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::max(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::max(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max2(tensor *out__, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::max(*self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_max_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::max_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_out1(tensor *out__, tensor max, tensor max_values, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::max_out(*max, *max_values, *self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_max_pool1d(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool1d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_pool1d_with_indices(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool1d_with_indices(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_max_pool2d(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool2d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_pool2d_with_indices(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool2d_with_indices(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_max_pool2d_with_indices_backward(tensor *out__, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode, tensor indices) {
  PROTECT(
    auto outputs__ = torch::max_pool2d_with_indices_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode, *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_pool2d_with_indices_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode, tensor indices) {
  PROTECT(
    auto outputs__ = torch::max_pool2d_with_indices_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode, *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_pool2d_with_indices_out(tensor *out__, tensor out, tensor indices, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool2d_with_indices_out(*out, *indices, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_max_pool3d(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool3d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_pool3d_with_indices(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool3d_with_indices(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_max_pool3d_with_indices_backward(tensor *out__, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode, tensor indices) {
  PROTECT(
    auto outputs__ = torch::max_pool3d_with_indices_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode, *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_pool3d_with_indices_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode, tensor indices) {
  PROTECT(
    auto outputs__ = torch::max_pool3d_with_indices_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode, *indices);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_pool3d_with_indices_out(tensor *out__, tensor out, tensor indices, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::max_pool3d_with_indices_out(*out, *indices, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_max_unpool2d(tensor *out__, tensor self, tensor indices, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool2d(*self, *indices, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_unpool2d_backward(tensor *out__, tensor grad_output, tensor self, tensor indices, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool2d_backward(*grad_output, *self, *indices, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_unpool2d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor indices, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool2d_backward_out(*grad_input, *grad_output, *self, *indices, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_unpool2d_out(tensor *out__, tensor out, tensor self, tensor indices, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool2d_out(*out, *self, *indices, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_unpool3d(tensor *out__, tensor self, tensor indices, int64_t *output_size_data, int output_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool3d(*self, *indices, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_unpool3d_backward(tensor *out__, tensor grad_output, tensor self, tensor indices, int64_t *output_size_data, int output_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool3d_backward(*grad_output, *self, *indices, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_unpool3d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor indices, int64_t *output_size_data, int output_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool3d_backward_out(*grad_input, *grad_output, *self, *indices, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_unpool3d_out(tensor *out__, tensor out, tensor self, tensor indices, int64_t *output_size_data, int output_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::max_unpool3d_out(*out, *self, *indices, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_max_values(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::max_values(*self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mean(tensor *out__, tensor self, int dtype) {
  PROTECT(
    auto outputs__ = torch::mean(*self, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mean1(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::mean(*self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mean_out(tensor *out__, tensor out, tensor self, int64_t *dim_data, int dim_len, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::mean_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_median(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::median(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_median1(tensor *out__, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::median(*self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_median_out(tensor *out__, tensor values, tensor indices, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::median_out(*values, *indices, *self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

tensor *atg_meshgrid(tensor *tensors_data, int tensors_len) {
  PROTECT(
    auto outputs__ = torch::meshgrid(of_carray_tensor(tensors_data, tensors_len));
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
  return nullptr;
}

void atg_min(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::min(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_min1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::min(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_min2(tensor *out__, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::min(*self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_min_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::min_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_min_out1(tensor *out__, tensor min, tensor min_indices, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::min_out(*min, *min_indices, *self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_min_values(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::min_values(*self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_miopen_batch_norm(tensor *out__, tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double exponential_average_factor, double epsilon) {
  PROTECT(
    auto outputs__ = torch::miopen_batch_norm(*input, *weight, (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)training, exponential_average_factor, epsilon);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_miopen_batch_norm_backward(tensor *out__, tensor input, tensor grad_output, tensor weight, tensor running_mean, tensor running_var, tensor save_mean, tensor save_var, double epsilon) {
  PROTECT(
    auto outputs__ = torch::miopen_batch_norm_backward(*input, *grad_output, *weight, (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (save_mean ? *save_mean : torch::Tensor()), (save_var ? *save_var : torch::Tensor()), epsilon);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_miopen_convolution(tensor *out__, tensor self, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution(*self, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_miopen_convolution_backward_bias(tensor *out__, tensor grad_output) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_backward_bias(*grad_output);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_miopen_convolution_backward_input(tensor *out__, int64_t *self_size_data, int self_size_len, tensor grad_output, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_backward_input(torch::IntArrayRef(self_size_data, self_size_len), *grad_output, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_miopen_convolution_backward_weight(tensor *out__, int64_t *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_backward_weight(torch::IntArrayRef(weight_size_data, weight_size_len), *grad_output, *self, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_miopen_convolution_transpose(tensor *out__, tensor self, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_transpose(*self, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_miopen_convolution_transpose_backward_input(tensor *out__, tensor grad_output, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_transpose_backward_input(*grad_output, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_miopen_convolution_transpose_backward_weight(tensor *out__, int64_t *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_convolution_transpose_backward_weight(torch::IntArrayRef(weight_size_data, weight_size_len), *grad_output, *self, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_miopen_depthwise_convolution(tensor *out__, tensor self, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_depthwise_convolution(*self, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_miopen_depthwise_convolution_backward_input(tensor *out__, int64_t *self_size_data, int self_size_len, tensor grad_output, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_depthwise_convolution_backward_input(torch::IntArrayRef(self_size_data, self_size_len), *grad_output, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_miopen_depthwise_convolution_backward_weight(tensor *out__, int64_t *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    auto outputs__ = torch::miopen_depthwise_convolution_backward_weight(torch::IntArrayRef(weight_size_data, weight_size_len), *grad_output, *self, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_miopen_rnn(tensor *out__, tensor input, tensor *weight_data, int weight_len, int64_t weight_stride0, tensor hx, tensor cx, int64_t mode, int64_t hidden_size, int64_t num_layers, int batch_first, double dropout, int train, int bidirectional, int64_t *batch_sizes_data, int batch_sizes_len, tensor dropout_state) {
  PROTECT(
    auto outputs__ = torch::miopen_rnn(*input, of_carray_tensor(weight_data, weight_len), weight_stride0, *hx, (cx ? *cx : torch::Tensor()), mode, hidden_size, num_layers, (bool)batch_first, dropout, (bool)train, (bool)bidirectional, torch::IntArrayRef(batch_sizes_data, batch_sizes_len), (dropout_state ? *dropout_state : torch::Tensor()));
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
    out__[3] = new torch::Tensor(std::get<3>(outputs__));
    out__[4] = new torch::Tensor(std::get<4>(outputs__));
  )
}

void atg_mkldnn_adaptive_avg_pool2d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len) {
  PROTECT(
    auto outputs__ = torch::mkldnn_adaptive_avg_pool2d(*self, torch::IntArrayRef(output_size_data, output_size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mkldnn_convolution(tensor *out__, tensor self, tensor weight, tensor bias, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::mkldnn_convolution(*self, *weight, (bias ? *bias : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mkldnn_convolution_backward_input(tensor *out__, int64_t *self_size_data, int self_size_len, tensor grad_output, tensor weight, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int bias_defined) {
  PROTECT(
    auto outputs__ = torch::mkldnn_convolution_backward_input(torch::IntArrayRef(self_size_data, self_size_len), *grad_output, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)bias_defined);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mkldnn_convolution_backward_weights(tensor *out__, int64_t *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups, int bias_defined) {
  PROTECT(
    auto outputs__ = torch::mkldnn_convolution_backward_weights(torch::IntArrayRef(weight_size_data, weight_size_len), *grad_output, *self, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, (bool)bias_defined);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_mkldnn_linear(tensor *out__, tensor input, tensor weight, tensor bias) {
  PROTECT(
    auto outputs__ = torch::mkldnn_linear(*input, *weight, (bias ? *bias : torch::Tensor()));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mkldnn_max_pool2d(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::mkldnn_max_pool2d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mkldnn_reorder_conv2d_weight(tensor *out__, tensor self, int64_t *padding_data, int padding_len, int64_t *stride_data, int stride_len, int64_t *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    auto outputs__ = torch::mkldnn_reorder_conv2d_weight(*self, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mm(tensor *out__, tensor self, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::mm(*self, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mm_out(tensor *out__, tensor out, tensor self, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::mm_out(*out, *self, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mode(tensor *out__, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::mode(*self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_mode_out(tensor *out__, tensor values, tensor indices, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    auto outputs__ = torch::mode_out(*values, *indices, *self, dim, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_mse_loss(tensor *out__, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::mse_loss(*self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mse_loss_backward(tensor *out__, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::mse_loss_backward(*grad_output, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mse_loss_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::mse_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mse_loss_out(tensor *out__, tensor out, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::mse_loss_out(*out, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mul(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::mul(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mul1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::mul(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mul_(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->mul_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mul_1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->mul_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mul_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::mul_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_multi_margin_loss_backward(tensor *out__, tensor grad_output, tensor self, tensor target, scalar p, scalar margin, tensor weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::multi_margin_loss_backward(*grad_output, *self, *target, *p, *margin, (weight ? *weight : torch::Tensor()), reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_multi_margin_loss_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor target, scalar p, scalar margin, tensor weight, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::multi_margin_loss_backward_out(*grad_input, *grad_output, *self, *target, *p, *margin, (weight ? *weight : torch::Tensor()), reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_multilabel_margin_loss(tensor *out__, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::multilabel_margin_loss(*self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_multilabel_margin_loss_backward(tensor *out__, tensor grad_output, tensor self, tensor target, int64_t reduction, tensor is_target) {
  PROTECT(
    auto outputs__ = torch::multilabel_margin_loss_backward(*grad_output, *self, *target, reduction, *is_target);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_multilabel_margin_loss_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction, tensor is_target) {
  PROTECT(
    auto outputs__ = torch::multilabel_margin_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction, *is_target);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_multilabel_margin_loss_out(tensor *out__, tensor out, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::multilabel_margin_loss_out(*out, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_multinomial(tensor *out__, tensor self, int64_t num_samples, int replacement) {
  PROTECT(
    auto outputs__ = torch::multinomial(*self, num_samples, (bool)replacement);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_multinomial_out(tensor *out__, tensor out, tensor self, int64_t num_samples, int replacement) {
  PROTECT(
    auto outputs__ = torch::multinomial_out(*out, *self, num_samples, (bool)replacement);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mv(tensor *out__, tensor self, tensor vec) {
  PROTECT(
    auto outputs__ = torch::mv(*self, *vec);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mv_out(tensor *out__, tensor out, tensor self, tensor vec) {
  PROTECT(
    auto outputs__ = torch::mv_out(*out, *self, *vec);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mvlgamma(tensor *out__, tensor self, int64_t p) {
  PROTECT(
    auto outputs__ = torch::mvlgamma(*self, p);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_mvlgamma_(tensor *out__, tensor self, int64_t p) {
  PROTECT(
    auto outputs__ = self->mvlgamma_(p);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_narrow(tensor *out__, tensor self, int64_t dim, int64_t start, int64_t length) {
  PROTECT(
    auto outputs__ = torch::narrow(*self, dim, start, length);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_narrow1(tensor *out__, tensor self, int64_t dim, tensor start, int64_t length) {
  PROTECT(
    auto outputs__ = torch::narrow(*self, dim, *start, length);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_narrow_copy(tensor *out__, tensor self, int64_t dim, int64_t start, int64_t length) {
  PROTECT(
    auto outputs__ = self->narrow_copy(dim, start, length);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_native_batch_norm(tensor *out__, tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double momentum, double eps) {
  PROTECT(
    auto outputs__ = torch::native_batch_norm(*input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)training, momentum, eps);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_native_batch_norm_out(tensor *out__, tensor out, tensor save_mean, tensor save_invstd, tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double momentum, double eps) {
  PROTECT(
    auto outputs__ = torch::native_batch_norm_out(*out, *save_mean, *save_invstd, *input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)training, momentum, eps);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_native_layer_norm(tensor *out__, tensor input, tensor weight, tensor bias, int64_t M, int64_t n, double eps) {
  PROTECT(
    auto outputs__ = torch::native_layer_norm(*input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), M, n, eps);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_native_norm(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::native_norm(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ne(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::ne(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ne1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::ne(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ne_(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->ne_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ne_1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->ne_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ne_out(tensor *out__, tensor out, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::ne_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ne_out1(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::ne_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_neg(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::neg(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_neg_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::neg_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_neg_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::neg_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_new_empty(tensor *out__, tensor self, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = self->new_empty(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_new_full(tensor *out__, tensor self, int64_t *size_data, int size_len, scalar fill_value, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = self->new_full(torch::IntArrayRef(size_data, size_len), *fill_value, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_new_zeros(tensor *out__, tensor self, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = self->new_zeros(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nll_loss(tensor *out__, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index) {
  PROTECT(
    auto outputs__ = torch::nll_loss(*self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nll_loss2d(tensor *out__, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index) {
  PROTECT(
    auto outputs__ = torch::nll_loss2d(*self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nll_loss2d_backward(tensor *out__, tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index, tensor total_weight) {
  PROTECT(
    auto outputs__ = torch::nll_loss2d_backward(*grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index, *total_weight);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nll_loss2d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index, tensor total_weight) {
  PROTECT(
    auto outputs__ = torch::nll_loss2d_backward_out(*grad_input, *grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index, *total_weight);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nll_loss2d_out(tensor *out__, tensor out, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index) {
  PROTECT(
    auto outputs__ = torch::nll_loss2d_out(*out, *self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nll_loss_backward(tensor *out__, tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index, tensor total_weight) {
  PROTECT(
    auto outputs__ = torch::nll_loss_backward(*grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index, *total_weight);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nll_loss_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index, tensor total_weight) {
  PROTECT(
    auto outputs__ = torch::nll_loss_backward_out(*grad_input, *grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index, *total_weight);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nll_loss_out(tensor *out__, tensor out, tensor self, tensor target, tensor weight, int64_t reduction, int64_t ignore_index) {
  PROTECT(
    auto outputs__ = torch::nll_loss_out(*out, *self, *target, (weight ? *weight : torch::Tensor()), reduction, ignore_index);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nonzero(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::nonzero(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

tensor *atg_nonzero_numpy(tensor self) {
  PROTECT(
    auto outputs__ = torch::nonzero_numpy(*self);
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
  return nullptr;
}

void atg_nonzero_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::nonzero_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_norm(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::norm(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_norm1(tensor *out__, tensor self, scalar p, int dtype) {
  PROTECT(
    auto outputs__ = torch::norm(*self, *p, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_norm2(tensor *out__, tensor self, scalar p, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::norm(*self, *p, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_norm3(tensor *out__, tensor self, scalar p, int64_t *dim_data, int dim_len, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::norm(*self, *p, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_norm_except_dim(tensor *out__, tensor v, int64_t pow, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::norm_except_dim(*v, pow, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_norm_out(tensor *out__, tensor out, tensor self, scalar p, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::norm_out(*out, *self, *p, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_norm_out1(tensor *out__, tensor out, tensor self, scalar p, int64_t *dim_data, int dim_len, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::norm_out(*out, *self, *p, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_normal_(tensor *out__, tensor self, double mean, double std) {
  PROTECT(
    auto outputs__ = self->normal_(mean, std);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_normal_out(tensor *out__, tensor out, tensor mean, double std) {
  PROTECT(
    auto outputs__ = torch::normal_out(*out, *mean, std);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_normal_out1(tensor *out__, tensor out, double mean, tensor std) {
  PROTECT(
    auto outputs__ = torch::normal_out(*out, mean, *std);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_normal_out2(tensor *out__, tensor out, tensor mean, tensor std) {
  PROTECT(
    auto outputs__ = torch::normal_out(*out, *mean, *std);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_normal_out3(tensor *out__, tensor out, double mean, double std, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::normal_out(*out, mean, std, torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nuclear_norm(tensor *out__, tensor self, int keepdim) {
  PROTECT(
    auto outputs__ = torch::nuclear_norm(*self, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nuclear_norm1(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::nuclear_norm(*self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nuclear_norm_out(tensor *out__, tensor out, tensor self, int keepdim) {
  PROTECT(
    auto outputs__ = torch::nuclear_norm_out(*out, *self, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_nuclear_norm_out1(tensor *out__, tensor out, tensor self, int64_t *dim_data, int dim_len, int keepdim) {
  PROTECT(
    auto outputs__ = torch::nuclear_norm_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_numpy_t(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->numpy_T();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_one_hot(tensor *out__, tensor self, int64_t num_classes) {
  PROTECT(
    auto outputs__ = torch::one_hot(*self, num_classes);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ones(tensor *out__, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::ones(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ones_like(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::ones_like(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ones_out(tensor *out__, tensor out, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::ones_out(*out, torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_orgqr(tensor *out__, tensor self, tensor input2) {
  PROTECT(
    auto outputs__ = torch::orgqr(*self, *input2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_orgqr_out(tensor *out__, tensor out, tensor self, tensor input2) {
  PROTECT(
    auto outputs__ = torch::orgqr_out(*out, *self, *input2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ormqr(tensor *out__, tensor self, tensor input2, tensor input3, int left, int transpose) {
  PROTECT(
    auto outputs__ = torch::ormqr(*self, *input2, *input3, (bool)left, (bool)transpose);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_ormqr_out(tensor *out__, tensor out, tensor self, tensor input2, tensor input3, int left, int transpose) {
  PROTECT(
    auto outputs__ = torch::ormqr_out(*out, *self, *input2, *input3, (bool)left, (bool)transpose);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pairwise_distance(tensor *out__, tensor x1, tensor x2, double p, double eps, int keepdim) {
  PROTECT(
    auto outputs__ = torch::pairwise_distance(*x1, *x2, p, eps, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pdist(tensor *out__, tensor self, double p) {
  PROTECT(
    auto outputs__ = torch::pdist(*self, p);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_permute(tensor *out__, tensor self, int64_t *dims_data, int dims_len) {
  PROTECT(
    auto outputs__ = self->permute(torch::IntArrayRef(dims_data, dims_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pin_memory(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->pin_memory();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pinverse(tensor *out__, tensor self, double rcond) {
  PROTECT(
    auto outputs__ = torch::pinverse(*self, rcond);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pixel_shuffle(tensor *out__, tensor self, int64_t upscale_factor) {
  PROTECT(
    auto outputs__ = torch::pixel_shuffle(*self, upscale_factor);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_poisson(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::poisson(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_poisson_nll_loss(tensor *out__, tensor input, tensor target, int log_input, int full, double eps, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::poisson_nll_loss(*input, *target, (bool)log_input, (bool)full, eps, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_polygamma(tensor *out__, int64_t n, tensor self) {
  PROTECT(
    auto outputs__ = torch::polygamma(n, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_polygamma_(tensor *out__, tensor self, int64_t n) {
  PROTECT(
    auto outputs__ = self->polygamma_(n);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_polygamma_out(tensor *out__, tensor out, int64_t n, tensor self) {
  PROTECT(
    auto outputs__ = torch::polygamma_out(*out, n, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pow(tensor *out__, tensor self, scalar exponent) {
  PROTECT(
    auto outputs__ = torch::pow(*self, *exponent);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pow1(tensor *out__, tensor self, tensor exponent) {
  PROTECT(
    auto outputs__ = torch::pow(*self, *exponent);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pow2(tensor *out__, scalar self_scalar, tensor exponent) {
  PROTECT(
    auto outputs__ = torch::pow(*self_scalar, *exponent);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pow_(tensor *out__, tensor self, scalar exponent) {
  PROTECT(
    auto outputs__ = self->pow_(*exponent);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pow_1(tensor *out__, tensor self, tensor exponent) {
  PROTECT(
    auto outputs__ = self->pow_(*exponent);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pow_out(tensor *out__, tensor out, tensor self, scalar exponent) {
  PROTECT(
    auto outputs__ = torch::pow_out(*out, *self, *exponent);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pow_out1(tensor *out__, tensor out, tensor self, tensor exponent) {
  PROTECT(
    auto outputs__ = torch::pow_out(*out, *self, *exponent);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_pow_out2(tensor *out__, tensor out, scalar self_scalar, tensor exponent) {
  PROTECT(
    auto outputs__ = torch::pow_out(*out, *self_scalar, *exponent);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_prelu(tensor *out__, tensor self, tensor weight) {
  PROTECT(
    auto outputs__ = torch::prelu(*self, *weight);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_prelu_backward(tensor *out__, tensor grad_output, tensor self, tensor weight) {
  PROTECT(
    auto outputs__ = torch::prelu_backward(*grad_output, *self, *weight);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_prod(tensor *out__, tensor self, int dtype) {
  PROTECT(
    auto outputs__ = torch::prod(*self, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_prod1(tensor *out__, tensor self, int64_t dim, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::prod(*self, dim, (bool)keepdim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_prod_out(tensor *out__, tensor out, tensor self, int64_t dim, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::prod_out(*out, *self, dim, (bool)keepdim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_put_(tensor *out__, tensor self, tensor index, tensor source, int accumulate) {
  PROTECT(
    auto outputs__ = self->put_(*index, *source, (bool)accumulate);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_q_per_channel_scales(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::q_per_channel_scales(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_q_per_channel_zero_points(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::q_per_channel_zero_points(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_qr(tensor *out__, tensor self, int some) {
  PROTECT(
    auto outputs__ = torch::qr(*self, (bool)some);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_qr_out(tensor *out__, tensor Q, tensor R, tensor self, int some) {
  PROTECT(
    auto outputs__ = torch::qr_out(*Q, *R, *self, (bool)some);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_quantize_per_channel(tensor *out__, tensor self, tensor scales, tensor zero_points, int64_t axis, int dtype) {
  PROTECT(
    auto outputs__ = torch::quantize_per_channel(*self, *scales, *zero_points, axis, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_quantize_per_tensor(tensor *out__, tensor self, double scale, int64_t zero_point, int dtype) {
  PROTECT(
    auto outputs__ = torch::quantize_per_tensor(*self, scale, zero_point, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_quantized_batch_norm(tensor *out__, tensor input, tensor weight, tensor bias, tensor mean, tensor var, double eps, double output_scale, int64_t output_zero_point) {
  PROTECT(
    auto outputs__ = torch::quantized_batch_norm(*input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), *mean, *var, eps, output_scale, output_zero_point);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_quantized_gru(tensor *out__, tensor input, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional, int batch_first) {
  PROTECT(
    auto outputs__ = torch::quantized_gru(*input, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional, (bool)batch_first);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_quantized_gru1(tensor *out__, tensor data, tensor batch_sizes, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional) {
  PROTECT(
    auto outputs__ = torch::quantized_gru(*data, *batch_sizes, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_quantized_gru_cell(tensor *out__, tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh, tensor packed_ih, tensor packed_hh, tensor col_offsets_ih, tensor col_offsets_hh, scalar scale_ih, scalar scale_hh, scalar zero_point_ih, scalar zero_point_hh) {
  PROTECT(
    auto outputs__ = torch::quantized_gru_cell(*input, *hx, *w_ih, *w_hh, *b_ih, *b_hh, *packed_ih, *packed_hh, *col_offsets_ih, *col_offsets_hh, *scale_ih, *scale_hh, *zero_point_ih, *zero_point_hh);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_quantized_lstm(tensor *out__, tensor input, tensor *hx_data, int hx_len, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional, int batch_first, int dtype, int use_dynamic) {
  PROTECT(
    auto outputs__ = torch::quantized_lstm(*input, of_carray_tensor(hx_data, hx_len), of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional, (bool)batch_first, at::ScalarType(dtype), (bool)use_dynamic);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_quantized_lstm1(tensor *out__, tensor data, tensor batch_sizes, tensor *hx_data, int hx_len, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional, int dtype, int use_dynamic) {
  PROTECT(
    auto outputs__ = torch::quantized_lstm(*data, *batch_sizes, of_carray_tensor(hx_data, hx_len), of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional, at::ScalarType(dtype), (bool)use_dynamic);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_quantized_lstm_cell(tensor *out__, tensor input, tensor *hx_data, int hx_len, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh, tensor packed_ih, tensor packed_hh, tensor col_offsets_ih, tensor col_offsets_hh, scalar scale_ih, scalar scale_hh, scalar zero_point_ih, scalar zero_point_hh) {
  PROTECT(
    auto outputs__ = torch::quantized_lstm_cell(*input, of_carray_tensor(hx_data, hx_len), *w_ih, *w_hh, *b_ih, *b_hh, *packed_ih, *packed_hh, *col_offsets_ih, *col_offsets_hh, *scale_ih, *scale_hh, *zero_point_ih, *zero_point_hh);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_quantized_max_pool2d(tensor *out__, tensor self, int64_t *kernel_size_data, int kernel_size_len, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    auto outputs__ = torch::quantized_max_pool2d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), (bool)ceil_mode);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_quantized_rnn_relu_cell(tensor *out__, tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh, tensor packed_ih, tensor packed_hh, tensor col_offsets_ih, tensor col_offsets_hh, scalar scale_ih, scalar scale_hh, scalar zero_point_ih, scalar zero_point_hh) {
  PROTECT(
    auto outputs__ = torch::quantized_rnn_relu_cell(*input, *hx, *w_ih, *w_hh, *b_ih, *b_hh, *packed_ih, *packed_hh, *col_offsets_ih, *col_offsets_hh, *scale_ih, *scale_hh, *zero_point_ih, *zero_point_hh);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_quantized_rnn_tanh_cell(tensor *out__, tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh, tensor packed_ih, tensor packed_hh, tensor col_offsets_ih, tensor col_offsets_hh, scalar scale_ih, scalar scale_hh, scalar zero_point_ih, scalar zero_point_hh) {
  PROTECT(
    auto outputs__ = torch::quantized_rnn_tanh_cell(*input, *hx, *w_ih, *w_hh, *b_ih, *b_hh, *packed_ih, *packed_hh, *col_offsets_ih, *col_offsets_hh, *scale_ih, *scale_hh, *zero_point_ih, *zero_point_hh);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rand(tensor *out__, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::rand(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rand_like(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::rand_like(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rand_out(tensor *out__, tensor out, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::rand_out(*out, torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_randint(tensor *out__, int64_t high, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::randint(high, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_randint1(tensor *out__, int64_t low, int64_t high, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::randint(low, high, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_randint_like(tensor *out__, tensor self, int64_t high) {
  PROTECT(
    auto outputs__ = torch::randint_like(*self, high);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_randint_like1(tensor *out__, tensor self, int64_t low, int64_t high) {
  PROTECT(
    auto outputs__ = torch::randint_like(*self, low, high);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_randint_out(tensor *out__, tensor out, int64_t high, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::randint_out(*out, high, torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_randint_out1(tensor *out__, tensor out, int64_t low, int64_t high, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::randint_out(*out, low, high, torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_randn(tensor *out__, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::randn(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_randn_like(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::randn_like(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_randn_out(tensor *out__, tensor out, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::randn_out(*out, torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_random_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->random_();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_random_1(tensor *out__, tensor self, int64_t to) {
  PROTECT(
    auto outputs__ = self->random_(to);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_random_2(tensor *out__, tensor self, int64_t from, int64_t to) {
  PROTECT(
    auto outputs__ = self->random_(from, to);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_randperm(tensor *out__, int64_t n, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::randperm(n, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_randperm_out(tensor *out__, tensor out, int64_t n) {
  PROTECT(
    auto outputs__ = torch::randperm_out(*out, n);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_range(tensor *out__, scalar start, scalar end, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::range(*start, *end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_range1(tensor *out__, scalar start, scalar end, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::range(*start, *end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_range_out(tensor *out__, tensor out, scalar start, scalar end) {
  PROTECT(
    auto outputs__ = torch::range_out(*out, *start, *end);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_real(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::real(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reciprocal(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::reciprocal(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reciprocal_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::reciprocal_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reciprocal_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::reciprocal_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reflection_pad1d(tensor *out__, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad1d(*self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reflection_pad1d_backward(tensor *out__, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad1d_backward(*grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reflection_pad1d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad1d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reflection_pad1d_out(tensor *out__, tensor out, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad1d_out(*out, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reflection_pad2d(tensor *out__, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad2d(*self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reflection_pad2d_backward(tensor *out__, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad2d_backward(*grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reflection_pad2d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad2d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reflection_pad2d_out(tensor *out__, tensor out, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::reflection_pad2d_out(*out, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_relu(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::relu(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_relu_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::relu_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_remainder(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::remainder(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_remainder1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::remainder(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_remainder_(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->remainder_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_remainder_1(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->remainder_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_remainder_out(tensor *out__, tensor out, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::remainder_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_remainder_out1(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::remainder_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_renorm(tensor *out__, tensor self, scalar p, int64_t dim, scalar maxnorm) {
  PROTECT(
    auto outputs__ = torch::renorm(*self, *p, dim, *maxnorm);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_renorm_(tensor *out__, tensor self, scalar p, int64_t dim, scalar maxnorm) {
  PROTECT(
    auto outputs__ = self->renorm_(*p, dim, *maxnorm);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_renorm_out(tensor *out__, tensor out, tensor self, scalar p, int64_t dim, scalar maxnorm) {
  PROTECT(
    auto outputs__ = torch::renorm_out(*out, *self, *p, dim, *maxnorm);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_repeat(tensor *out__, tensor self, int64_t *repeats_data, int repeats_len) {
  PROTECT(
    auto outputs__ = self->repeat(torch::IntArrayRef(repeats_data, repeats_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_repeat_interleave(tensor *out__, tensor repeats) {
  PROTECT(
    auto outputs__ = torch::repeat_interleave(*repeats);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_repeat_interleave1(tensor *out__, tensor self, tensor repeats, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::repeat_interleave(*self, *repeats, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_repeat_interleave2(tensor *out__, tensor self, int64_t repeats, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::repeat_interleave(*self, repeats, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad1d(tensor *out__, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad1d(*self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad1d_backward(tensor *out__, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad1d_backward(*grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad1d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad1d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad1d_out(tensor *out__, tensor out, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad1d_out(*out, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad2d(tensor *out__, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad2d(*self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad2d_backward(tensor *out__, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad2d_backward(*grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad2d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad2d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad2d_out(tensor *out__, tensor out, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad2d_out(*out, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad3d(tensor *out__, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad3d(*self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad3d_backward(tensor *out__, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad3d_backward(*grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad3d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad3d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_replication_pad3d_out(tensor *out__, tensor out, tensor self, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::replication_pad3d_out(*out, *self, torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_requires_grad_(tensor *out__, tensor self, int _requires_grad) {
  PROTECT(
    auto outputs__ = self->requires_grad_((bool)_requires_grad);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reshape(tensor *out__, tensor self, int64_t *shape_data, int shape_len) {
  PROTECT(
    auto outputs__ = torch::reshape(*self, torch::IntArrayRef(shape_data, shape_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_reshape_as(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->reshape_as(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_resize_(tensor *out__, tensor self, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = self->resize_(torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_resize_as_(tensor *out__, tensor self, tensor the_template) {
  PROTECT(
    auto outputs__ = torch::resize_as_(*self, *the_template);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rfft(tensor *out__, tensor self, int64_t signal_ndim, int normalized, int onesided) {
  PROTECT(
    auto outputs__ = torch::rfft(*self, signal_ndim, (bool)normalized, (bool)onesided);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rnn_relu(tensor *out__, tensor input, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional, int batch_first) {
  PROTECT(
    auto outputs__ = torch::rnn_relu(*input, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional, (bool)batch_first);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_rnn_relu1(tensor *out__, tensor data, tensor batch_sizes, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional) {
  PROTECT(
    auto outputs__ = torch::rnn_relu(*data, *batch_sizes, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_rnn_relu_cell(tensor *out__, tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh) {
  PROTECT(
    auto outputs__ = torch::rnn_relu_cell(*input, *hx, *w_ih, *w_hh, (b_ih ? *b_ih : torch::Tensor()), (b_hh ? *b_hh : torch::Tensor()));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rnn_tanh(tensor *out__, tensor input, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional, int batch_first) {
  PROTECT(
    auto outputs__ = torch::rnn_tanh(*input, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional, (bool)batch_first);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_rnn_tanh1(tensor *out__, tensor data, tensor batch_sizes, tensor hx, tensor *params_data, int params_len, int has_biases, int64_t num_layers, double dropout, int train, int bidirectional) {
  PROTECT(
    auto outputs__ = torch::rnn_tanh(*data, *batch_sizes, *hx, of_carray_tensor(params_data, params_len), (bool)has_biases, num_layers, dropout, (bool)train, (bool)bidirectional);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_rnn_tanh_cell(tensor *out__, tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh) {
  PROTECT(
    auto outputs__ = torch::rnn_tanh_cell(*input, *hx, *w_ih, *w_hh, (b_ih ? *b_ih : torch::Tensor()), (b_hh ? *b_hh : torch::Tensor()));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_roll(tensor *out__, tensor self, int64_t *shifts_data, int shifts_len, int64_t *dims_data, int dims_len) {
  PROTECT(
    auto outputs__ = torch::roll(*self, torch::IntArrayRef(shifts_data, shifts_len), torch::IntArrayRef(dims_data, dims_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rot90(tensor *out__, tensor self, int64_t k, int64_t *dims_data, int dims_len) {
  PROTECT(
    auto outputs__ = torch::rot90(*self, k, torch::IntArrayRef(dims_data, dims_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_round(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::round(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_round_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::round_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_round_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::round_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rrelu(tensor *out__, tensor self, int training) {
  PROTECT(
    auto outputs__ = torch::rrelu(*self, (bool)training);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rrelu_(tensor *out__, tensor self, int training) {
  PROTECT(
    auto outputs__ = torch::rrelu_(*self, (bool)training);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rrelu_with_noise(tensor *out__, tensor self, tensor noise, int training) {
  PROTECT(
    auto outputs__ = torch::rrelu_with_noise(*self, *noise, (bool)training);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rrelu_with_noise_(tensor *out__, tensor self, tensor noise, int training) {
  PROTECT(
    auto outputs__ = torch::rrelu_with_noise_(*self, *noise, (bool)training);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rrelu_with_noise_backward(tensor *out__, tensor grad_output, tensor self, tensor noise, scalar lower, scalar upper, int training, int self_is_result) {
  PROTECT(
    auto outputs__ = torch::rrelu_with_noise_backward(*grad_output, *self, *noise, *lower, *upper, (bool)training, (bool)self_is_result);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rrelu_with_noise_out(tensor *out__, tensor out, tensor self, tensor noise, int training) {
  PROTECT(
    auto outputs__ = torch::rrelu_with_noise_out(*out, *self, *noise, (bool)training);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rsqrt(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::rsqrt(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rsqrt_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::rsqrt_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rsqrt_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::rsqrt_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rsub(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::rsub(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_rsub1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::rsub(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_scalar_tensor(tensor *out__, scalar s, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::scalar_tensor(*s, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_scatter(tensor *out__, tensor self, int64_t dim, tensor index, tensor src) {
  PROTECT(
    auto outputs__ = torch::scatter(*self, dim, *index, *src);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_scatter1(tensor *out__, tensor self, int64_t dim, tensor index, scalar value) {
  PROTECT(
    auto outputs__ = torch::scatter(*self, dim, *index, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_scatter_(tensor *out__, tensor self, int64_t dim, tensor index, tensor src) {
  PROTECT(
    auto outputs__ = self->scatter_(dim, *index, *src);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_scatter_1(tensor *out__, tensor self, int64_t dim, tensor index, scalar value) {
  PROTECT(
    auto outputs__ = self->scatter_(dim, *index, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_scatter_add(tensor *out__, tensor self, int64_t dim, tensor index, tensor src) {
  PROTECT(
    auto outputs__ = torch::scatter_add(*self, dim, *index, *src);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_scatter_add_(tensor *out__, tensor self, int64_t dim, tensor index, tensor src) {
  PROTECT(
    auto outputs__ = self->scatter_add_(dim, *index, *src);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_select(tensor *out__, tensor self, int64_t dim, int64_t index) {
  PROTECT(
    auto outputs__ = torch::select(*self, dim, index);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_selu(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::selu(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_selu_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::selu_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_set_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->set_();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_set_1(tensor *out__, tensor self, tensor source) {
  PROTECT(
    auto outputs__ = self->set_(*source);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_set_requires_grad(tensor *out__, tensor self, int r) {
  PROTECT(
    auto outputs__ = self->set_requires_grad((bool)r);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sigmoid(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::sigmoid(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sigmoid_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::sigmoid_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sigmoid_backward(tensor *out__, tensor grad_output, tensor output) {
  PROTECT(
    auto outputs__ = torch::sigmoid_backward(*grad_output, *output);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sigmoid_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor output) {
  PROTECT(
    auto outputs__ = torch::sigmoid_backward_out(*grad_input, *grad_output, *output);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sigmoid_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::sigmoid_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sign(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::sign(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sign_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->sign_();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sign_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::sign_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sin(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::sin(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sin_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::sin_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sin_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::sin_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sinh(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::sinh(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sinh_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::sinh_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sinh_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::sinh_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_slice(tensor *out__, tensor self, int64_t dim, int64_t start, int64_t end, int64_t step) {
  PROTECT(
    auto outputs__ = torch::slice(*self, dim, start, end, step);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_slogdet(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::slogdet(*self);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_slow_conv3d(tensor *out__, tensor self, tensor weight, int64_t *kernel_size_data, int kernel_size_len, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::slow_conv3d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_slow_conv3d_out(tensor *out__, tensor out, tensor self, tensor weight, int64_t *kernel_size_data, int kernel_size_len, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len) {
  PROTECT(
    auto outputs__ = torch::slow_conv3d_out(*out, *self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_slow_conv_dilated2d(tensor *out__, tensor self, tensor weight, int64_t *kernel_size_data, int kernel_size_len, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::slow_conv_dilated2d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_slow_conv_dilated3d(tensor *out__, tensor self, tensor weight, int64_t *kernel_size_data, int kernel_size_len, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::slow_conv_dilated3d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_slow_conv_transpose2d(tensor *out__, tensor self, tensor weight, int64_t *kernel_size_data, int kernel_size_len, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::slow_conv_transpose2d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(dilation_data, dilation_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_slow_conv_transpose2d_out(tensor *out__, tensor out, tensor self, tensor weight, int64_t *kernel_size_data, int kernel_size_len, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::slow_conv_transpose2d_out(*out, *self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(dilation_data, dilation_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_slow_conv_transpose3d(tensor *out__, tensor self, tensor weight, int64_t *kernel_size_data, int kernel_size_len, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::slow_conv_transpose3d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(dilation_data, dilation_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_slow_conv_transpose3d_out(tensor *out__, tensor out, tensor self, tensor weight, int64_t *kernel_size_data, int kernel_size_len, tensor bias, int64_t *stride_data, int stride_len, int64_t *padding_data, int padding_len, int64_t *output_padding_data, int output_padding_len, int64_t *dilation_data, int dilation_len) {
  PROTECT(
    auto outputs__ = torch::slow_conv_transpose3d_out(*out, *self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias ? *bias : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(dilation_data, dilation_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_smm(tensor *out__, tensor self, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::smm(*self, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_smooth_l1_loss(tensor *out__, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::smooth_l1_loss(*self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_smooth_l1_loss_backward(tensor *out__, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::smooth_l1_loss_backward(*grad_output, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_smooth_l1_loss_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::smooth_l1_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_smooth_l1_loss_out(tensor *out__, tensor out, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::smooth_l1_loss_out(*out, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_soft_margin_loss(tensor *out__, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::soft_margin_loss(*self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_soft_margin_loss_backward(tensor *out__, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::soft_margin_loss_backward(*grad_output, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_soft_margin_loss_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::soft_margin_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_soft_margin_loss_out(tensor *out__, tensor out, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::soft_margin_loss_out(*out, *self, *target, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_softmax(tensor *out__, tensor self, int64_t dim, int dtype) {
  PROTECT(
    auto outputs__ = torch::softmax(*self, dim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_softplus(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::softplus(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_softplus_backward(tensor *out__, tensor grad_output, tensor self, scalar beta, scalar threshold, tensor output) {
  PROTECT(
    auto outputs__ = torch::softplus_backward(*grad_output, *self, *beta, *threshold, *output);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_softplus_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, scalar beta, scalar threshold, tensor output) {
  PROTECT(
    auto outputs__ = torch::softplus_backward_out(*grad_input, *grad_output, *self, *beta, *threshold, *output);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_softplus_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::softplus_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_softshrink(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::softshrink(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_softshrink_backward(tensor *out__, tensor grad_output, tensor self, scalar lambd) {
  PROTECT(
    auto outputs__ = torch::softshrink_backward(*grad_output, *self, *lambd);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_softshrink_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor self, scalar lambd) {
  PROTECT(
    auto outputs__ = torch::softshrink_backward_out(*grad_input, *grad_output, *self, *lambd);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_softshrink_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::softshrink_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_solve(tensor *out__, tensor self, tensor A) {
  PROTECT(
    auto outputs__ = torch::solve(*self, *A);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_solve_out(tensor *out__, tensor solution, tensor lu, tensor self, tensor A) {
  PROTECT(
    auto outputs__ = torch::solve_out(*solution, *lu, *self, *A);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_sort(tensor *out__, tensor self, int64_t dim, int descending) {
  PROTECT(
    auto outputs__ = torch::sort(*self, dim, (bool)descending);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_sort_out(tensor *out__, tensor values, tensor indices, tensor self, int64_t dim, int descending) {
  PROTECT(
    auto outputs__ = torch::sort_out(*values, *indices, *self, dim, (bool)descending);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_sparse_coo_tensor(tensor *out__, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::sparse_coo_tensor(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sparse_coo_tensor1(tensor *out__, tensor indices, tensor values, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::sparse_coo_tensor(*indices, *values, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sparse_coo_tensor2(tensor *out__, tensor indices, tensor values, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::sparse_coo_tensor(*indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sparse_mask(tensor *out__, tensor self, tensor mask) {
  PROTECT(
    auto outputs__ = self->sparse_mask(*mask);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sparse_resize_(tensor *out__, tensor self, int64_t *size_data, int size_len, int64_t sparse_dim, int64_t dense_dim) {
  PROTECT(
    auto outputs__ = self->sparse_resize_(torch::IntArrayRef(size_data, size_len), sparse_dim, dense_dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sparse_resize_and_clear_(tensor *out__, tensor self, int64_t *size_data, int size_len, int64_t sparse_dim, int64_t dense_dim) {
  PROTECT(
    auto outputs__ = self->sparse_resize_and_clear_(torch::IntArrayRef(size_data, size_len), sparse_dim, dense_dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

tensor *atg_split(tensor self, int64_t split_size, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::split(*self, split_size, dim);
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
  return nullptr;
}

tensor *atg_split_with_sizes(tensor self, int64_t *split_sizes_data, int split_sizes_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::split_with_sizes(*self, torch::IntArrayRef(split_sizes_data, split_sizes_len), dim);
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
  return nullptr;
}

void atg_sqrt(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::sqrt(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sqrt_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::sqrt_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sqrt_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::sqrt_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_square(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::square(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_square_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::square_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_squeeze(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::squeeze(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_squeeze1(tensor *out__, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::squeeze(*self, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_squeeze_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->squeeze_();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_squeeze_1(tensor *out__, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = self->squeeze_(dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sspaddmm(tensor *out__, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::sspaddmm(*self, *mat1, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sspaddmm_out(tensor *out__, tensor out, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    auto outputs__ = torch::sspaddmm_out(*out, *self, *mat1, *mat2);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_stack(tensor *out__, tensor *tensors_data, int tensors_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::stack(of_carray_tensor(tensors_data, tensors_len), dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_stack_out(tensor *out__, tensor out, tensor *tensors_data, int tensors_len, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::stack_out(*out, of_carray_tensor(tensors_data, tensors_len), dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_std(tensor *out__, tensor self, int unbiased) {
  PROTECT(
    auto outputs__ = torch::std(*self, (bool)unbiased);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_std1(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int unbiased, int keepdim) {
  PROTECT(
    auto outputs__ = torch::std(*self, torch::IntArrayRef(dim_data, dim_len), (bool)unbiased, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_std_mean(tensor *out__, tensor self, int unbiased) {
  PROTECT(
    auto outputs__ = torch::std_mean(*self, (bool)unbiased);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_std_mean1(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int unbiased, int keepdim) {
  PROTECT(
    auto outputs__ = torch::std_mean(*self, torch::IntArrayRef(dim_data, dim_len), (bool)unbiased, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_std_out(tensor *out__, tensor out, tensor self, int64_t *dim_data, int dim_len, int unbiased, int keepdim) {
  PROTECT(
    auto outputs__ = torch::std_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), (bool)unbiased, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_stft(tensor *out__, tensor self, int64_t n_fft, int64_t hop_length, int64_t win_length, tensor window, int normalized, int onesided) {
  PROTECT(
    auto outputs__ = torch::stft(*self, n_fft, hop_length, win_length, (window ? *window : torch::Tensor()), (bool)normalized, (bool)onesided);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sub(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::sub(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sub1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::sub(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sub_(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->sub_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sub_1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->sub_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sub_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::sub_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sum(tensor *out__, tensor self, int dtype) {
  PROTECT(
    auto outputs__ = torch::sum(*self, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sum1(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::sum(*self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sum_out(tensor *out__, tensor out, tensor self, int64_t *dim_data, int dim_len, int keepdim, int dtype) {
  PROTECT(
    auto outputs__ = torch::sum_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), (bool)keepdim, at::ScalarType(dtype));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_sum_to_size(tensor *out__, tensor self, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = self->sum_to_size(torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_svd(tensor *out__, tensor self, int some, int compute_uv) {
  PROTECT(
    auto outputs__ = torch::svd(*self, (bool)some, (bool)compute_uv);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_svd_out(tensor *out__, tensor U, tensor S, tensor V, tensor self, int some, int compute_uv) {
  PROTECT(
    auto outputs__ = torch::svd_out(*U, *S, *V, *self, (bool)some, (bool)compute_uv);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_symeig(tensor *out__, tensor self, int eigenvectors, int upper) {
  PROTECT(
    auto outputs__ = torch::symeig(*self, (bool)eigenvectors, (bool)upper);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_symeig_out(tensor *out__, tensor e, tensor V, tensor self, int eigenvectors, int upper) {
  PROTECT(
    auto outputs__ = torch::symeig_out(*e, *V, *self, (bool)eigenvectors, (bool)upper);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_t(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::t(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_t_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->t_();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_take(tensor *out__, tensor self, tensor index) {
  PROTECT(
    auto outputs__ = torch::take(*self, *index);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_take_out(tensor *out__, tensor out, tensor self, tensor index) {
  PROTECT(
    auto outputs__ = torch::take_out(*out, *self, *index);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tan(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::tan(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tan_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::tan_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tan_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::tan_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tanh(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::tanh(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tanh_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::tanh_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tanh_backward(tensor *out__, tensor grad_output, tensor output) {
  PROTECT(
    auto outputs__ = torch::tanh_backward(*grad_output, *output);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tanh_backward_out(tensor *out__, tensor grad_input, tensor grad_output, tensor output) {
  PROTECT(
    auto outputs__ = torch::tanh_backward_out(*grad_input, *grad_output, *output);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tanh_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::tanh_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tensordot(tensor *out__, tensor self, tensor other, int64_t *dims_self_data, int dims_self_len, int64_t *dims_other_data, int dims_other_len) {
  PROTECT(
    auto outputs__ = torch::tensordot(*self, *other, torch::IntArrayRef(dims_self_data, dims_self_len), torch::IntArrayRef(dims_other_data, dims_other_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_threshold(tensor *out__, tensor self, scalar threshold, scalar value) {
  PROTECT(
    auto outputs__ = torch::threshold(*self, *threshold, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_threshold_(tensor *out__, tensor self, scalar threshold, scalar value) {
  PROTECT(
    auto outputs__ = torch::threshold_(*self, *threshold, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_threshold_backward(tensor *out__, tensor grad_output, tensor self, scalar threshold) {
  PROTECT(
    auto outputs__ = torch::threshold_backward(*grad_output, *self, *threshold);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_threshold_out(tensor *out__, tensor out, tensor self, scalar threshold, scalar value) {
  PROTECT(
    auto outputs__ = torch::threshold_out(*out, *self, *threshold, *value);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_to(tensor *out__, tensor self, int device) {
  PROTECT(
    auto outputs__ = self->to(device_of_int(device));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_to1(tensor *out__, tensor self, int options_kind, int options_device, int non_blocking, int copy) {
  PROTECT(
    auto outputs__ = self->to(at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (bool)non_blocking, (bool)copy);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_to2(tensor *out__, tensor self, int dtype, int non_blocking, int copy) {
  PROTECT(
    auto outputs__ = self->to(at::ScalarType(dtype), (bool)non_blocking, (bool)copy);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_to3(tensor *out__, tensor self, tensor other, int non_blocking, int copy) {
  PROTECT(
    auto outputs__ = self->to(*other, (bool)non_blocking, (bool)copy);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_to4(tensor *out__, tensor self, int device, int dtype, int non_blocking, int copy) {
  PROTECT(
    auto outputs__ = self->to(device_of_int(device), at::ScalarType(dtype), (bool)non_blocking, (bool)copy);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_to_dense(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->to_dense();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_to_dense_backward(tensor *out__, tensor grad, tensor input) {
  PROTECT(
    auto outputs__ = torch::to_dense_backward(*grad, *input);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_to_mkldnn(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->to_mkldnn();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_to_mkldnn_backward(tensor *out__, tensor grad, tensor input) {
  PROTECT(
    auto outputs__ = torch::to_mkldnn_backward(*grad, *input);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_to_sparse(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->to_sparse();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_to_sparse1(tensor *out__, tensor self, int64_t sparse_dim) {
  PROTECT(
    auto outputs__ = self->to_sparse(sparse_dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_topk(tensor *out__, tensor self, int64_t k, int64_t dim, int largest, int sorted) {
  PROTECT(
    auto outputs__ = torch::topk(*self, k, dim, (bool)largest, (bool)sorted);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_topk_out(tensor *out__, tensor values, tensor indices, tensor self, int64_t k, int64_t dim, int largest, int sorted) {
  PROTECT(
    auto outputs__ = torch::topk_out(*values, *indices, *self, k, dim, (bool)largest, (bool)sorted);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_totype(tensor *out__, tensor self, int scalar_type) {
  PROTECT(
    auto outputs__ = self->toType(at::ScalarType(scalar_type));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_trace(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::trace(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_transpose(tensor *out__, tensor self, int64_t dim0, int64_t dim1) {
  PROTECT(
    auto outputs__ = torch::transpose(*self, dim0, dim1);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_transpose_(tensor *out__, tensor self, int64_t dim0, int64_t dim1) {
  PROTECT(
    auto outputs__ = self->transpose_(dim0, dim1);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_trapz(tensor *out__, tensor y, tensor x, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::trapz(*y, *x, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_trapz1(tensor *out__, tensor y, double dx, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::trapz(*y, dx, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_triangular_solve(tensor *out__, tensor self, tensor A, int upper, int transpose, int unitriangular) {
  PROTECT(
    auto outputs__ = torch::triangular_solve(*self, *A, (bool)upper, (bool)transpose, (bool)unitriangular);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_triangular_solve_out(tensor *out__, tensor X, tensor M, tensor self, tensor A, int upper, int transpose, int unitriangular) {
  PROTECT(
    auto outputs__ = torch::triangular_solve_out(*X, *M, *self, *A, (bool)upper, (bool)transpose, (bool)unitriangular);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_tril(tensor *out__, tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::tril(*self, diagonal);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tril_(tensor *out__, tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = self->tril_(diagonal);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tril_indices(tensor *out__, int64_t row, int64_t col, int64_t offset, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::tril_indices(row, col, offset, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_tril_out(tensor *out__, tensor out, tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::tril_out(*out, *self, diagonal);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_triplet_margin_loss(tensor *out__, tensor anchor, tensor positive, tensor negative, double margin, double p, double eps, int swap, int64_t reduction) {
  PROTECT(
    auto outputs__ = torch::triplet_margin_loss(*anchor, *positive, *negative, margin, p, eps, (bool)swap, reduction);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_triu(tensor *out__, tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::triu(*self, diagonal);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_triu_(tensor *out__, tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = self->triu_(diagonal);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_triu_indices(tensor *out__, int64_t row, int64_t col, int64_t offset, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::triu_indices(row, col, offset, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_triu_out(tensor *out__, tensor out, tensor self, int64_t diagonal) {
  PROTECT(
    auto outputs__ = torch::triu_out(*out, *self, diagonal);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_true_divide(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::true_divide(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_true_divide1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = torch::true_divide(*self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_true_divide_(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->true_divide_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_true_divide_1(tensor *out__, tensor self, scalar other) {
  PROTECT(
    auto outputs__ = self->true_divide_(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_true_divide_out(tensor *out__, tensor out, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::true_divide_out(*out, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_trunc(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::trunc(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_trunc_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::trunc_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_trunc_out(tensor *out__, tensor out, tensor self) {
  PROTECT(
    auto outputs__ = torch::trunc_out(*out, *self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_type_as(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->type_as(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

tensor *atg_unbind(tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::unbind(*self, dim);
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
  return nullptr;
}

void atg_unfold(tensor *out__, tensor self, int64_t dimension, int64_t size, int64_t step) {
  PROTECT(
    auto outputs__ = self->unfold(dimension, size, step);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_uniform_(tensor *out__, tensor self, double from, double to) {
  PROTECT(
    auto outputs__ = self->uniform_(from, to);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_unique_consecutive(tensor *out__, tensor self, int return_inverse, int return_counts, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::unique_consecutive(*self, (bool)return_inverse, (bool)return_counts, dim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_unique_dim(tensor *out__, tensor self, int64_t dim, int sorted, int return_inverse, int return_counts) {
  PROTECT(
    auto outputs__ = torch::unique_dim(*self, dim, (bool)sorted, (bool)return_inverse, (bool)return_counts);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_unique_dim_consecutive(tensor *out__, tensor self, int64_t dim, int return_inverse, int return_counts) {
  PROTECT(
    auto outputs__ = torch::unique_dim_consecutive(*self, dim, (bool)return_inverse, (bool)return_counts);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
    out__[2] = new torch::Tensor(std::get<2>(outputs__));
  )
}

void atg_unsqueeze(tensor *out__, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = torch::unsqueeze(*self, dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_unsqueeze_(tensor *out__, tensor self, int64_t dim) {
  PROTECT(
    auto outputs__ = self->unsqueeze_(dim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_bicubic2d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len, int align_corners, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_bicubic2d(*self, torch::IntArrayRef(output_size_data, output_size_len), (bool)align_corners, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_bicubic2d_backward(tensor *out__, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_bicubic2d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), (bool)align_corners, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_bicubic2d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_bicubic2d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), (bool)align_corners, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_bicubic2d_out(tensor *out__, tensor out, tensor self, int64_t *output_size_data, int output_size_len, int align_corners, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_bicubic2d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), (bool)align_corners, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_bilinear2d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len, int align_corners, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_bilinear2d(*self, torch::IntArrayRef(output_size_data, output_size_len), (bool)align_corners, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_bilinear2d_backward(tensor *out__, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_bilinear2d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), (bool)align_corners, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_bilinear2d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_bilinear2d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), (bool)align_corners, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_bilinear2d_out(tensor *out__, tensor out, tensor self, int64_t *output_size_data, int output_size_len, int align_corners, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_bilinear2d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), (bool)align_corners, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_linear1d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len, int align_corners, double scales) {
  PROTECT(
    auto outputs__ = torch::upsample_linear1d(*self, torch::IntArrayRef(output_size_data, output_size_len), (bool)align_corners, scales);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_linear1d_backward(tensor *out__, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners, double scales) {
  PROTECT(
    auto outputs__ = torch::upsample_linear1d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), (bool)align_corners, scales);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_linear1d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners, double scales) {
  PROTECT(
    auto outputs__ = torch::upsample_linear1d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), (bool)align_corners, scales);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_linear1d_out(tensor *out__, tensor out, tensor self, int64_t *output_size_data, int output_size_len, int align_corners, double scales) {
  PROTECT(
    auto outputs__ = torch::upsample_linear1d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), (bool)align_corners, scales);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest1d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len, double scales) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest1d(*self, torch::IntArrayRef(output_size_data, output_size_len), scales);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest1d_backward(tensor *out__, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, double scales) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest1d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest1d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, double scales) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest1d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest1d_out(tensor *out__, tensor out, tensor self, int64_t *output_size_data, int output_size_len, double scales) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest1d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), scales);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest2d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest2d(*self, torch::IntArrayRef(output_size_data, output_size_len), scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest2d_backward(tensor *out__, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest2d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest2d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest2d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest2d_out(tensor *out__, tensor out, tensor self, int64_t *output_size_data, int output_size_len, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest2d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest3d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len, double scales_d, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest3d(*self, torch::IntArrayRef(output_size_data, output_size_len), scales_d, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest3d_backward(tensor *out__, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, double scales_d, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest3d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_d, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest3d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, double scales_d, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest3d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_d, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_nearest3d_out(tensor *out__, tensor out, tensor self, int64_t *output_size_data, int output_size_len, double scales_d, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_nearest3d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), scales_d, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_trilinear3d(tensor *out__, tensor self, int64_t *output_size_data, int output_size_len, int align_corners, double scales_d, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_trilinear3d(*self, torch::IntArrayRef(output_size_data, output_size_len), (bool)align_corners, scales_d, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_trilinear3d_backward(tensor *out__, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners, double scales_d, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_trilinear3d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), (bool)align_corners, scales_d, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_trilinear3d_backward_out(tensor *out__, tensor grad_input, tensor grad_output, int64_t *output_size_data, int output_size_len, int64_t *input_size_data, int input_size_len, int align_corners, double scales_d, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_trilinear3d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), (bool)align_corners, scales_d, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_upsample_trilinear3d_out(tensor *out__, tensor out, tensor self, int64_t *output_size_data, int output_size_len, int align_corners, double scales_d, double scales_h, double scales_w) {
  PROTECT(
    auto outputs__ = torch::upsample_trilinear3d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), (bool)align_corners, scales_d, scales_h, scales_w);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_values(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = self->values();
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_var(tensor *out__, tensor self, int unbiased) {
  PROTECT(
    auto outputs__ = torch::var(*self, (bool)unbiased);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_var1(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int unbiased, int keepdim) {
  PROTECT(
    auto outputs__ = torch::var(*self, torch::IntArrayRef(dim_data, dim_len), (bool)unbiased, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_var_mean(tensor *out__, tensor self, int unbiased) {
  PROTECT(
    auto outputs__ = torch::var_mean(*self, (bool)unbiased);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_var_mean1(tensor *out__, tensor self, int64_t *dim_data, int dim_len, int unbiased, int keepdim) {
  PROTECT(
    auto outputs__ = torch::var_mean(*self, torch::IntArrayRef(dim_data, dim_len), (bool)unbiased, (bool)keepdim);
    out__[0] = new torch::Tensor(std::get<0>(outputs__));
    out__[1] = new torch::Tensor(std::get<1>(outputs__));
  )
}

void atg_var_out(tensor *out__, tensor out, tensor self, int64_t *dim_data, int dim_len, int unbiased, int keepdim) {
  PROTECT(
    auto outputs__ = torch::var_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), (bool)unbiased, (bool)keepdim);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_view(tensor *out__, tensor self, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = self->view(torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_view_as(tensor *out__, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = self->view_as(*other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

tensor *atg_where(tensor condition) {
  PROTECT(
    auto outputs__ = torch::where(*condition);
    int sz = outputs__.size();
    torch::Tensor **out__ = (torch::Tensor**)malloc((sz + 1) * sizeof(torch::Tensor*));
    for (int i = 0; i < sz; ++i)
      out__[i] = new torch::Tensor(outputs__[i]);
    out__[sz] = nullptr;
    return out__;
  )
  return nullptr;
}

void atg_where1(tensor *out__, tensor condition, tensor self, tensor other) {
  PROTECT(
    auto outputs__ = torch::where(*condition, *self, *other);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_zero_(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::zero_(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_zeros(tensor *out__, int64_t *size_data, int size_len, int options_kind, int options_device) {
  PROTECT(
    auto outputs__ = torch::zeros(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_zeros_like(tensor *out__, tensor self) {
  PROTECT(
    auto outputs__ = torch::zeros_like(*self);
    out__[0] = new torch::Tensor(outputs__);
  )
}

void atg_zeros_out(tensor *out__, tensor out, int64_t *size_data, int size_len) {
  PROTECT(
    auto outputs__ = torch::zeros_out(*out, torch::IntArrayRef(size_data, size_len));
    out__[0] = new torch::Tensor(outputs__);
  )
}

